<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="4" failures="12" skipped="1" tests="31" time="681.304" timestamp="2025-09-05T14:32:19.174860+08:00" hostname="DESKTOP-FDB8GR9"><testcase classname="tests.test_convergence.TestConvergence" name="test_direct_link_failure" time="253.539"><failure message="AssertionError: 未找到Root Port&#10;assert None">self = &lt;test_convergence.TestConvergence object at 0x00000250807B7610&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x00000250808B4050&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x000002508088CF50&gt;, &lt;src.ssh_manager.SSHManager object at 0x000002508088E5D0&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x00000250808B56A0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x00000250808B57F0&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x00000250808B5940&gt;
convergence_monitor = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x00000250808B5A90&gt;

    def test_direct_link_failure(self, dut_manager, test_nodes,
                                 network_topology, rstp_analyzer,
                                 fault_injector, convergence_monitor):
        """TC.AUTO.2.1: 直接链路故障测试"""
        logger.info("开始直接链路故障测试")
    
        # 创建环形拓扑提供冗余路径
        network_topology.create_ring_topology(use_rstp=True)
    
        # 等待初始收敛
        analyzers = [rstp_analyzer] + [RSTPAnalyzer(node) for node in test_nodes]
        initial_convergence = convergence_monitor.wait_for_convergence(analyzers)
        logger.info(f"初始收敛时间: {initial_convergence:.2f}秒")
    
        # 确定DUT的Root Port
        info = rstp_analyzer.get_bridge_info()
        root_port = None
        for port_name, port_info in info.ports.items():
            if port_info.role == PortRole.ROOT:
                root_port = port_name
                break
    
&gt;       assert root_port, "未找到Root Port"
E       AssertionError: 未找到Root Port
E       assert None

tests\test_convergence.py:44: AssertionError</failure></testcase><testcase classname="tests.test_convergence.TestConvergence" name="test_root_bridge_failure" time="0.037"><error message="failed on setup with &quot;RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe&quot;">fixturedef = &lt;FixtureDef argname='vmware_controller' scope='session' baseid=''&gt;
request = &lt;SubRequest 'vmware_controller' for &lt;Function test_root_bridge_failure&gt;&gt;

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -&gt; object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
&gt;               return (yield)
                        ^^^^^

..\..\..\AppData\Roaming\Python\Python313\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
conftest.py:94: in vmware_controller
    return VMwareController(vmrun_path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.vmware_controller.VMwareController object at 0x00000250808B67B0&gt;
vmrun_path = 'C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe'

    def __init__(self, vmrun_path: str = "/usr/bin/vmrun"):
        """
        初始化VMware控制器
    
        Args:
            vmrun_path: vmrun工具路径
        """
        self.vmrun = vmrun_path
        self.logger = logging.getLogger("VMwareController")
    
        # 验证vmrun是否存在
        if not self._check_vmrun():
&gt;           raise RuntimeError(f"vmrun工具未找到: {vmrun_path}")
E           RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe

src\vmware_controller.py:48: RuntimeError</error></testcase><testcase classname="tests.test_convergence.TestConvergence" name="test_multiple_link_failures" time="29.474" /><testcase classname="tests.test_convergence.TestConvergence" name="test_convergence_with_traffic" time="34.715" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_primary_controller_failure" time="0.001"><error message="failed on setup with &quot;RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe&quot;">test_config = {'rstp_parameters': {'bridge_priority': {'invalid': [4097, 12289, 70000], 'max': 61440, 'min': 12288, 'step': 4096}, '... {'interfaces': ['eth0', 'eth2', 'eth1'], 'ip': '192.168.13.137', 'name': 'TestNode2', 'password': '8N10xiaol', ...}]}}

    @pytest.fixture(scope="session")
    def vmware_controller(test_config):
        """VMware控制器fixture"""
        vmrun_path = test_config['test_environment']['vmware']['vmrun_path']
&gt;       return VMwareController(vmrun_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

conftest.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.vmware_controller.VMwareController object at 0x00000250808B67B0&gt;
vmrun_path = 'C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe'

    def __init__(self, vmrun_path: str = "/usr/bin/vmrun"):
        """
        初始化VMware控制器
    
        Args:
            vmrun_path: vmrun工具路径
        """
        self.vmrun = vmrun_path
        self.logger = logging.getLogger("VMwareController")
    
        # 验证vmrun是否存在
        if not self._check_vmrun():
&gt;           raise RuntimeError(f"vmrun工具未找到: {vmrun_path}")
E           RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe

src\vmware_controller.py:48: RuntimeError</error></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_rstp_reconvergence_no_switchover" time="27.420" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_split_brain_scenario" time="10.200" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_ha_switchover_with_traffic" time="0.001"><error message="failed on setup with &quot;RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe&quot;">test_config = {'rstp_parameters': {'bridge_priority': {'invalid': [4097, 12289, 70000], 'max': 61440, 'min': 12288, 'step': 4096}, '... {'interfaces': ['eth0', 'eth2', 'eth1'], 'ip': '192.168.13.137', 'name': 'TestNode2', 'password': '8N10xiaol', ...}]}}

    @pytest.fixture(scope="session")
    def vmware_controller(test_config):
        """VMware控制器fixture"""
        vmrun_path = test_config['test_environment']['vmware']['vmrun_path']
&gt;       return VMwareController(vmrun_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

conftest.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.vmware_controller.VMwareController object at 0x00000250808B67B0&gt;
vmrun_path = 'C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe'

    def __init__(self, vmrun_path: str = "/usr/bin/vmrun"):
        """
        初始化VMware控制器
    
        Args:
            vmrun_path: vmrun工具路径
        """
        self.vmrun = vmrun_path
        self.logger = logging.getLogger("VMwareController")
    
        # 验证vmrun是否存在
        if not self._check_vmrun():
&gt;           raise RuntimeError(f"vmrun工具未找到: {vmrun_path}")
E           RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe

src\vmware_controller.py:48: RuntimeError</error></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_ha_failback" time="0.002"><error message="failed on setup with &quot;RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe&quot;">test_config = {'rstp_parameters': {'bridge_priority': {'invalid': [4097, 12289, 70000], 'max': 61440, 'min': 12288, 'step': 4096}, '... {'interfaces': ['eth0', 'eth2', 'eth1'], 'ip': '192.168.13.137', 'name': 'TestNode2', 'password': '8N10xiaol', ...}]}}

    @pytest.fixture(scope="session")
    def vmware_controller(test_config):
        """VMware控制器fixture"""
        vmrun_path = test_config['test_environment']['vmware']['vmrun_path']
&gt;       return VMwareController(vmrun_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

conftest.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.vmware_controller.VMwareController object at 0x00000250808B67B0&gt;
vmrun_path = 'C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe'

    def __init__(self, vmrun_path: str = "/usr/bin/vmrun"):
        """
        初始化VMware控制器
    
        Args:
            vmrun_path: vmrun工具路径
        """
        self.vmrun = vmrun_path
        self.logger = logging.getLogger("VMwareController")
    
        # 验证vmrun是否存在
        if not self._check_vmrun():
&gt;           raise RuntimeError(f"vmrun工具未找到: {vmrun_path}")
E           RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe

src\vmware_controller.py:48: RuntimeError</error></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[12288]" time="0.201"><failure message="AssertionError: 设置优先级失败: stdout='1&#13;&#10;  1&#13;&#10;  set bridge priority failed: Operation not supported&#13;&#10;  ', stderr='', code=1&#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000002508088C050&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x00000250808F3240&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x00000250808F1D00&gt;
priority = 12288

    @pytest.mark.parametrize("priority", [12288, 16384, 32768, 61440])
    def test_bridge_priority_valid(self, dut_manager, rstp_analyzer, priority):
        """TC.AUTO.3.1.1-2: 测试有效的网桥优先级"""
        logger.info(f"测试网桥优先级: {priority}")
    
        # 设置网桥优先级
        stdout, stderr, code = NetworkTopology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
        logger.info(f"命令执行结果: code={code}, stdout='{stdout}', stderr='{stderr}'")
&gt;       assert code == 0, f"设置优先级失败: stdout='{stdout}', stderr='{stderr}', code={code}"
E       AssertionError: 设置优先级失败: stdout='1
E         1
E         set bridge priority failed: Operation not supported
E         ', stderr='', code=1
E       assert 1 == 0

tests\test_parameters.py:44: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[16384]" time="0.038"><failure message="AssertionError: 设置优先级失败: stdout='1&#13;&#10;  1&#13;&#10;  set bridge priority failed: Operation not supported&#13;&#10;  ', stderr='', code=1&#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000002508088C190&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x00000250808F3240&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000025080877D50&gt;
priority = 16384

    @pytest.mark.parametrize("priority", [12288, 16384, 32768, 61440])
    def test_bridge_priority_valid(self, dut_manager, rstp_analyzer, priority):
        """TC.AUTO.3.1.1-2: 测试有效的网桥优先级"""
        logger.info(f"测试网桥优先级: {priority}")
    
        # 设置网桥优先级
        stdout, stderr, code = NetworkTopology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
        logger.info(f"命令执行结果: code={code}, stdout='{stdout}', stderr='{stderr}'")
&gt;       assert code == 0, f"设置优先级失败: stdout='{stdout}', stderr='{stderr}', code={code}"
E       AssertionError: 设置优先级失败: stdout='1
E         1
E         set bridge priority failed: Operation not supported
E         ', stderr='', code=1
E       assert 1 == 0

tests\test_parameters.py:44: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[32768]" time="0.040"><failure message="AssertionError: 设置优先级失败: stdout='1&#13;&#10;  1&#13;&#10;  set bridge priority failed: Operation not supported&#13;&#10;  ', stderr='', code=1&#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x00000250807275C0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x00000250808F3240&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000025080990150&gt;
priority = 32768

    @pytest.mark.parametrize("priority", [12288, 16384, 32768, 61440])
    def test_bridge_priority_valid(self, dut_manager, rstp_analyzer, priority):
        """TC.AUTO.3.1.1-2: 测试有效的网桥优先级"""
        logger.info(f"测试网桥优先级: {priority}")
    
        # 设置网桥优先级
        stdout, stderr, code = NetworkTopology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
        logger.info(f"命令执行结果: code={code}, stdout='{stdout}', stderr='{stderr}'")
&gt;       assert code == 0, f"设置优先级失败: stdout='{stdout}', stderr='{stderr}', code={code}"
E       AssertionError: 设置优先级失败: stdout='1
E         1
E         set bridge priority failed: Operation not supported
E         ', stderr='', code=1
E       assert 1 == 0

tests\test_parameters.py:44: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[61440]" time="0.040"><failure message="AssertionError: 设置优先级失败: stdout='1&#13;&#10;  1&#13;&#10;  set bridge priority failed: Operation not supported&#13;&#10;  ', stderr='', code=1&#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x0000025080727820&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x00000250808F3240&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x00000250809A9D60&gt;
priority = 61440

    @pytest.mark.parametrize("priority", [12288, 16384, 32768, 61440])
    def test_bridge_priority_valid(self, dut_manager, rstp_analyzer, priority):
        """TC.AUTO.3.1.1-2: 测试有效的网桥优先级"""
        logger.info(f"测试网桥优先级: {priority}")
    
        # 设置网桥优先级
        stdout, stderr, code = NetworkTopology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
        logger.info(f"命令执行结果: code={code}, stdout='{stdout}', stderr='{stderr}'")
&gt;       assert code == 0, f"设置优先级失败: stdout='{stdout}', stderr='{stderr}', code={code}"
E       AssertionError: 设置优先级失败: stdout='1
E         1
E         set bridge priority failed: Operation not supported
E         ', stderr='', code=1
E       assert 1 == 0

tests\test_parameters.py:44: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[4097]" time="0.039" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[12289]" time="0.054" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[70000]" time="0.052" /><testcase classname="tests.test_parameters.TestParameters" name="test_hello_time" time="0.055"><failure message="AssertionError: 设置Hello Time失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x0000025080874550&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x00000250808F3240&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x00000250809AAB70&gt;

    def test_hello_time(self, dut_manager, rstp_analyzer):
        """TC.AUTO.3.1.4: Hello Time测试"""
        logger.info("测试Hello Time参数")
    
        # 测试不同的hello time值
        for hello_time in [1, 2, 5]:
            logger.info(f"设置Hello Time: {hello_time}秒")
    
            # 设置参数
            stdout, stderr, code = NetworkTopology.execute_bridge_command(
                dut_manager, "set_hello_time", hello_time=hello_time
            )
    
&gt;           assert code == 0, f"设置Hello Time失败: {stderr}"
E           AssertionError: 设置Hello Time失败: 
E           assert 1 == 0

tests\test_parameters.py:96: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_forward_delay" time="0.038"><failure message="AssertionError: 设置Forward Delay失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x0000025080874750&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x00000250808F3240&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x00000250809D8D70&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x0000025080899370&gt;

    def test_forward_delay(self, dut_manager, rstp_analyzer, fault_injector):
        """TC.AUTO.3.1.5: Forward Delay测试"""
        logger.info("测试Forward Delay参数")
    
        # 测试不同的forward delay值
        for fd in [4, 10, 15]:
            logger.info(f"设置Forward Delay: {fd}秒")
    
            # 设置参数
            stdout, stderr, code = NetworkTopology.execute_bridge_command(
                dut_manager, "set_forward_delay", forward_delay=fd
            )
&gt;           assert code == 0, f"设置Forward Delay失败: {stderr}"
E           AssertionError: 设置Forward Delay失败: 
E           assert 1 == 0

tests\test_parameters.py:136: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_max_age" time="0.037"><failure message="AssertionError: 设置Max Age失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x00000250807CE7B0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x00000250808F3240&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x00000250809D9A90&gt;

    def test_max_age(self, dut_manager, rstp_analyzer):
        """TC.AUTO.3.1.6: Max Age测试"""
        logger.info("测试Max Age参数")
    
        for max_age in [6, 10, 20]:
            logger.info(f"设置Max Age: {max_age}秒")
    
            # 设置参数
            stdout, stderr, code = NetworkTopology.execute_bridge_command(
                dut_manager, "set_max_age", max_age=max_age
            )
    
&gt;           assert code == 0, f"设置Max Age失败: {stderr}"
E           AssertionError: 设置Max Age失败: 
E           assert 1 == 0

tests\test_parameters.py:186: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_port_cost" time="126.255" /><testcase classname="tests.test_parameters.TestParameters" name="test_parameter_persistence" time="3.306" /><testcase classname="tests.test_parameters.TestParameters" name="test_parameter_boundaries" time="0.838" /><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_root_bridge_election" time="52.222"><failure message="AssertionError: DUT不应该是根网桥（优先级较高）&#10;assert not True&#10; +  where True = is_root_bridge()&#10; +    where is_root_bridge = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000025080A60AD0&gt;.is_root_bridge">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x000002508088C2D0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000025080991550&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x00000250809B6030&gt;, &lt;src.ssh_manager.SSHManager object at 0x00000250809B7110&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x00000250808CCB00&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000025080A60AD0&gt;

    def test_root_bridge_election(self, dut_manager, test_nodes,
                                  network_topology, rstp_analyzer):
        """TC.AUTO.1.1: 根网桥选举测试"""
        logger.info("开始根网桥选举测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 设置节点优先级
        NetworkTopology.execute_bridge_command(test_nodes[0], "set_priority", priority=16384)
        NetworkTopology.execute_bridge_command(dut_manager, "set_priority", priority=32768)
    
        # 等待收敛
        time.sleep(5)
    
        # 验证DUT不是根网桥
&gt;       assert not rstp_analyzer.is_root_bridge(), \
            "DUT不应该是根网桥（优先级较高）"
E       AssertionError: DUT不应该是根网桥（优先级较高）
E       assert not True
E        +  where True = is_root_bridge()
E        +    where is_root_bridge = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000025080A60AD0&gt;.is_root_bridge

tests\test_protocol_conformance.py:36: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_port_role_assignment" time="11.671"><failure message="AssertionError: DUT应该有Root Port&#10;assert &lt;PortRole.ROOT: 'root'&gt; in {}&#10; +  where &lt;PortRole.ROOT: 'root'&gt; = PortRole.ROOT">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x000002508088C410&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000025080991550&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x00000250809B6030&gt;, &lt;src.ssh_manager.SSHManager object at 0x00000250809B7110&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x00000250808CCB00&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x00000250809C4AA0&gt;

    def test_port_role_assignment(self, dut_manager, test_nodes,
                                  network_topology, rstp_analyzer):
        """TC.AUTO.1.2: 端口角色与状态分配测试"""
        logger.info("开始端口角色分配测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 确保测试节点1是根网桥
        NetworkTopology.execute_bridge_command(test_nodes[0], "set_priority", priority=12288)
        NetworkTopology.execute_bridge_command(dut_manager, "set_priority", priority=32768)
    
        # 等待收敛
        time.sleep(5)
    
        # 获取DUT端口信息
        info = rstp_analyzer.get_bridge_info()
    
        # 统计端口角色
        roles = {}
        for port_name, port_info in info.ports.items():
            role = port_info.role
            if role not in roles:
                roles[role] = []
            roles[role].append(port_name)
    
        # 验证有且仅有一个Root Port
&gt;       assert PortRole.ROOT in roles, "DUT应该有Root Port"
E       AssertionError: DUT应该有Root Port
E       assert &lt;PortRole.ROOT: 'root'&gt; in {}
E        +  where &lt;PortRole.ROOT: 'root'&gt; = PortRole.ROOT

tests\test_protocol_conformance.py:84: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_rstp_protocol_verification" time="0.124"><failure message="AssertionError: 应该检测到RSTP BPDU&#10;assert 0 &gt; 0&#10; +  where 0 = len([])">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000025080727950&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000025080991550&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x00000250809C5180&gt;

    def test_rstp_protocol_verification(self, dut_manager, rstp_analyzer):
        """验证使用的是RSTP而不是STP"""
        logger.info("开始RSTP协议验证")
    
        # 验证协议版本
        assert rstp_analyzer.verify_rstp_enabled(), \
            "DUT应该使用RSTP协议"
    
        # 检查BPDU格式
        bpdus = rstp_analyzer.capture_bpdu("eth0", count=5, timeout=15)
    
        rstp_bpdus = [b for b in bpdus if b.get('is_rstp', False)]
&gt;       assert len(rstp_bpdus) &gt; 0, "应该检测到RSTP BPDU"
E       AssertionError: 应该检测到RSTP BPDU
E       assert 0 &gt; 0
E        +  where 0 = len([])

tests\test_protocol_conformance.py:112: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_topology_change_notification" time="19.102"><failure message="AssertionError: 应该检测到拓扑变更&#10;assert 0 &gt; 0">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000025080727A80&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000025080991550&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x00000250809B6030&gt;, &lt;src.ssh_manager.SSHManager object at 0x00000250809B7110&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x00000250808CCB00&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000025080A228F0&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x000002508089A360&gt;

    def test_topology_change_notification(self, dut_manager, test_nodes,
                                          network_topology, rstp_analyzer,
                                          fault_injector):
        """测试拓扑变更通知机制"""
        logger.info("开始拓扑变更通知测试")
    
        # 创建稳定拓扑
        network_topology.create_ring_topology(use_rstp=True)
        time.sleep(5)
    
        # 记录初始拓扑变更计数
        initial_info = rstp_analyzer.get_bridge_info()
        initial_changes = initial_info.topology_changes
    
        # 触发拓扑变更
        fault_injector.link_down("eth0")
        time.sleep(2)
        fault_injector.link_up("eth0")
        time.sleep(5)
    
        # 检查拓扑变更计数
        final_info = rstp_analyzer.get_bridge_info()
        final_changes = final_info.topology_changes
    
&gt;       assert final_changes &gt; initial_changes, \
            "应该检测到拓扑变更"
E       AssertionError: 应该检测到拓扑变更
E       assert 0 &gt; 0

tests\test_protocol_conformance.py:145: AssertionError</failure></testcase><testcase classname="tests.test_security.TestSecurity" name="test_root_bridge_hijack_attack" time="32.360" /><testcase classname="tests.test_security.TestSecurity" name="test_bpdu_flood_attack" time="21.925" /><testcase classname="tests.test_security.TestSecurity" name="test_topology_change_attack" time="39.104" /><testcase classname="tests.test_security.TestSecurity" name="test_mac_spoofing" time="17.688" /><testcase classname="tests.test_security.TestSecurity" name="test_port_security" time="0.010"><skipped type="pytest.skip" message="端口安全功能不可用">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_security.py:249: 端口安全功能不可用</skipped></testcase></testsuite></testsuites>