<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="11" skipped="8" tests="56" time="2098.921" timestamp="2025-09-11T00:14:43.280791+08:00" hostname="DESKTOP-FDB8GR9"><testcase classname="tests.test_additional_rstp.TestAdditionalRSTP" name="test_port_state_transitions" time="26.999"><skipped type="pytest.skip" message="没有找到活动端口，跳过状态转换测试">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_additional_rstp.py:56: 没有找到活动端口，跳过状态转换测试</skipped></testcase><testcase classname="tests.test_additional_rstp.TestAdditionalRSTP" name="test_bpdu_propagation_and_keepalive" time="254.006" /><testcase classname="tests.test_additional_rstp.TestAdditionalRSTP" name="test_disabled_port_exclusion_enhanced" time="40.486"><skipped type="pytest.skip" message="需要至少2个活动端口进行测试">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_additional_rstp.py:314: 需要至少2个活动端口进行测试</skipped></testcase><testcase classname="tests.test_advanced_rstp_mechanisms.TestAdvancedRSTPMechanisms" name="test_proposal_agreement_handshake" time="34.349" /><testcase classname="tests.test_advanced_rstp_mechanisms.TestAdvancedRSTPMechanisms" name="test_tcn_topology_change_notification" time="39.930" /><testcase classname="tests.test_advanced_rstp_mechanisms.TestAdvancedRSTPMechanisms" name="test_edge_port_behavior" time="29.249" /><testcase classname="tests.test_advanced_rstp_mechanisms.TestAdvancedRSTPMechanisms" name="test_shared_vs_point_to_point_links" time="28.451" /><testcase classname="tests.test_backup_port_simulation.TestBackupPortSimulation" name="test_backup_port_concept_verification" time="30.986" /><testcase classname="tests.test_backup_port_simulation.TestBackupPortSimulation" name="test_shared_medium_simulation_attempt" time="30.013" /><testcase classname="tests.test_backup_port_simulation.TestBackupPortSimulation" name="test_backup_port_documentation_verification" time="0.006" /><testcase classname="tests.test_convergence.TestConvergence" name="test_direct_link_failure" time="37.203" /><testcase classname="tests.test_convergence.TestConvergence" name="test_root_bridge_failure" time="0.041"><skipped type="pytest.skip" message="跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_convergence.py:80: 跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe</skipped></testcase><testcase classname="tests.test_convergence.TestConvergence" name="test_multiple_link_failures" time="35.149" /><testcase classname="tests.test_convergence.TestConvergence" name="test_convergence_with_traffic" time="47.373" /><testcase classname="tests.test_enhanced_rstp_coverage.TestEnhancedRSTPCoverage" name="test_backup_port_simulation" time="21.070" /><testcase classname="tests.test_enhanced_rstp_coverage.TestEnhancedRSTPCoverage" name="test_comprehensive_port_state_transitions" time="102.492" /><testcase classname="tests.test_enhanced_rstp_coverage.TestEnhancedRSTPCoverage" name="test_detailed_bpdu_analysis" time="73.191" /><testcase classname="tests.test_enhanced_rstp_coverage.TestEnhancedRSTPCoverage" name="test_topology_change_comprehensive" time="88.069" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_primary_controller_failure" time="0.001"><skipped type="pytest.skip" message="跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_high_availability.py:40: 跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe</skipped></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_rstp_reconvergence_no_switchover" time="34.938" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_split_brain_scenario" time="10.543" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_ha_switchover_with_traffic" time="0.000"><skipped type="pytest.skip" message="跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_high_availability.py:178: 跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe</skipped></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_ha_failback" time="0.002"><skipped type="pytest.skip" message="跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_high_availability.py:227: 跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe</skipped></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[12288]" time="4.038" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[16384]" time="3.858" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[32768]" time="3.860" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[61440]" time="3.866" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[4097]" time="2.027"><failure message="Failed: DUT违反802.1D标准：接受了无效优先级 4097，实际设置为 4097（不是4096的倍数）">self = &lt;test_parameters.TestParameters object at 0x0000018AD781F530&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD7893C20&gt;, priority = 4097

    @pytest.mark.parametrize("priority", [4097, 12289, 70000])
    def test_bridge_priority_invalid(self, dut_manager, priority):
        """TC.AUTO.3.1.3: 测试无效的网桥优先级"""
        logger.info(f"测试无效优先级: {priority}")
    
        # 确保网桥存在并正确配置
        bridge_name = "SE_ETH2" if dut_manager.config.name == "DUT" else "br0"
    
        # 创建网桥
        if dut_manager.config.name == "DUT":
            # 对于DUT，创建OVS网桥
            dut_manager.execute_sudo(f"ovs-vsctl --if-exists del-br {bridge_name}")
            dut_manager.execute_sudo(f"ovs-vsctl add-br {bridge_name}")
            dut_manager.execute_sudo(f"ovs-vsctl set bridge {bridge_name} stp_enable=true")
            dut_manager.execute_sudo(f"ovs-vsctl set bridge {bridge_name} rstp_enable=true")
        else:
            dut_manager.execute_sudo(f"brctl addbr {bridge_name} 2&gt;/dev/null || true")
            dut_manager.execute_sudo(f"brctl stp {bridge_name} on")
        dut_manager.execute_sudo(f"ip link set {bridge_name} up")
    
        # 尝试设置无效优先级
        network_topology = NetworkTopology([dut_manager])
        stdout, stderr, code = network_topology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
    
        # 对于DUT（OVS），验证其对无效值的处理
        if dut_manager.config.name == "DUT":
            # 验证OVS是否正确处理了无效值
            time.sleep(1)
            stdout_check, _, code_check = dut_manager.execute_as_root(
                f"ovs-vsctl get bridge {bridge_name} other-config:stp-priority"
            )
            if code_check == 0:
                import re
                match = re.search(r'"(\d+)"', stdout_check)
                if match:
                    actual_priority = int(match.group(1))
                    logger.info(f"DUT处理无效优先级 {priority} -&gt; {actual_priority}")
    
                    # 记录DUT的行为：是否遵循802.1D标准（优先级应为4096的倍数）
                    if actual_priority % 4096 != 0:
                        logger.error(f"DUT接受了非标准优先级值 {actual_priority}，不符合802.1D标准（应为4096的倍数）")
                        # 这是一个合规性问题，测试应该失败
&gt;                       pytest.fail(f"DUT违反802.1D标准：接受了无效优先级 {priority}，实际设置为 {actual_priority}（不是4096的倍数）")
E                       Failed: DUT违反802.1D标准：接受了无效优先级 4097，实际设置为 4097（不是4096的倍数）

tests\test_parameters.py:198: Failed</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[12289]" time="1.963"><failure message="Failed: DUT违反802.1D标准：接受了无效优先级 12289，实际设置为 12289（不是4096的倍数）">self = &lt;test_parameters.TestParameters object at 0x0000018AD7860380&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD7893C20&gt;, priority = 12289

    @pytest.mark.parametrize("priority", [4097, 12289, 70000])
    def test_bridge_priority_invalid(self, dut_manager, priority):
        """TC.AUTO.3.1.3: 测试无效的网桥优先级"""
        logger.info(f"测试无效优先级: {priority}")
    
        # 确保网桥存在并正确配置
        bridge_name = "SE_ETH2" if dut_manager.config.name == "DUT" else "br0"
    
        # 创建网桥
        if dut_manager.config.name == "DUT":
            # 对于DUT，创建OVS网桥
            dut_manager.execute_sudo(f"ovs-vsctl --if-exists del-br {bridge_name}")
            dut_manager.execute_sudo(f"ovs-vsctl add-br {bridge_name}")
            dut_manager.execute_sudo(f"ovs-vsctl set bridge {bridge_name} stp_enable=true")
            dut_manager.execute_sudo(f"ovs-vsctl set bridge {bridge_name} rstp_enable=true")
        else:
            dut_manager.execute_sudo(f"brctl addbr {bridge_name} 2&gt;/dev/null || true")
            dut_manager.execute_sudo(f"brctl stp {bridge_name} on")
        dut_manager.execute_sudo(f"ip link set {bridge_name} up")
    
        # 尝试设置无效优先级
        network_topology = NetworkTopology([dut_manager])
        stdout, stderr, code = network_topology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
    
        # 对于DUT（OVS），验证其对无效值的处理
        if dut_manager.config.name == "DUT":
            # 验证OVS是否正确处理了无效值
            time.sleep(1)
            stdout_check, _, code_check = dut_manager.execute_as_root(
                f"ovs-vsctl get bridge {bridge_name} other-config:stp-priority"
            )
            if code_check == 0:
                import re
                match = re.search(r'"(\d+)"', stdout_check)
                if match:
                    actual_priority = int(match.group(1))
                    logger.info(f"DUT处理无效优先级 {priority} -&gt; {actual_priority}")
    
                    # 记录DUT的行为：是否遵循802.1D标准（优先级应为4096的倍数）
                    if actual_priority % 4096 != 0:
                        logger.error(f"DUT接受了非标准优先级值 {actual_priority}，不符合802.1D标准（应为4096的倍数）")
                        # 这是一个合规性问题，测试应该失败
&gt;                       pytest.fail(f"DUT违反802.1D标准：接受了无效优先级 {priority}，实际设置为 {actual_priority}（不是4096的倍数）")
E                       Failed: DUT违反802.1D标准：接受了无效优先级 12289，实际设置为 12289（不是4096的倍数）

tests\test_parameters.py:198: Failed</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[70000]" time="2.037"><failure message="Failed: DUT违反802.1D标准：接受了无效优先级 70000，实际设置为 70000（不是4096的倍数）">self = &lt;test_parameters.TestParameters object at 0x0000018AD7860490&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD7893C20&gt;, priority = 70000

    @pytest.mark.parametrize("priority", [4097, 12289, 70000])
    def test_bridge_priority_invalid(self, dut_manager, priority):
        """TC.AUTO.3.1.3: 测试无效的网桥优先级"""
        logger.info(f"测试无效优先级: {priority}")
    
        # 确保网桥存在并正确配置
        bridge_name = "SE_ETH2" if dut_manager.config.name == "DUT" else "br0"
    
        # 创建网桥
        if dut_manager.config.name == "DUT":
            # 对于DUT，创建OVS网桥
            dut_manager.execute_sudo(f"ovs-vsctl --if-exists del-br {bridge_name}")
            dut_manager.execute_sudo(f"ovs-vsctl add-br {bridge_name}")
            dut_manager.execute_sudo(f"ovs-vsctl set bridge {bridge_name} stp_enable=true")
            dut_manager.execute_sudo(f"ovs-vsctl set bridge {bridge_name} rstp_enable=true")
        else:
            dut_manager.execute_sudo(f"brctl addbr {bridge_name} 2&gt;/dev/null || true")
            dut_manager.execute_sudo(f"brctl stp {bridge_name} on")
        dut_manager.execute_sudo(f"ip link set {bridge_name} up")
    
        # 尝试设置无效优先级
        network_topology = NetworkTopology([dut_manager])
        stdout, stderr, code = network_topology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
    
        # 对于DUT（OVS），验证其对无效值的处理
        if dut_manager.config.name == "DUT":
            # 验证OVS是否正确处理了无效值
            time.sleep(1)
            stdout_check, _, code_check = dut_manager.execute_as_root(
                f"ovs-vsctl get bridge {bridge_name} other-config:stp-priority"
            )
            if code_check == 0:
                import re
                match = re.search(r'"(\d+)"', stdout_check)
                if match:
                    actual_priority = int(match.group(1))
                    logger.info(f"DUT处理无效优先级 {priority} -&gt; {actual_priority}")
    
                    # 记录DUT的行为：是否遵循802.1D标准（优先级应为4096的倍数）
                    if actual_priority % 4096 != 0:
                        logger.error(f"DUT接受了非标准优先级值 {actual_priority}，不符合802.1D标准（应为4096的倍数）")
                        # 这是一个合规性问题，测试应该失败
&gt;                       pytest.fail(f"DUT违反802.1D标准：接受了无效优先级 {priority}，实际设置为 {actual_priority}（不是4096的倍数）")
E                       Failed: DUT违反802.1D标准：接受了无效优先级 70000，实际设置为 70000（不是4096的倍数）

tests\test_parameters.py:198: Failed</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_hello_time" time="8.391" /><testcase classname="tests.test_parameters.TestParameters" name="test_forward_delay" time="8.404" /><testcase classname="tests.test_parameters.TestParameters" name="test_max_age" time="8.390" /><testcase classname="tests.test_parameters.TestParameters" name="test_port_cost" time="252.142" /><testcase classname="tests.test_parameters.TestParameters" name="test_parameter_persistence" time="7.595" /><testcase classname="tests.test_parameters.TestParameters" name="test_parameter_boundaries" time="3.197" /><testcase classname="tests.test_protocol_conformance" name="test_port_role_assignment_simplified" time="43.815"><skipped type="pytest.skip" message="跳过测试：DUT的br3接口链路DOWN，这是基础设施问题而非RSTP算法问题。请检查br3的物理连接。当前拓扑不完整，无法进行端口角色分配测试。">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_protocol_conformance.py:61: 跳过测试：DUT的br3接口链路DOWN，这是基础设施问题而非RSTP算法问题。请检查br3的物理连接。当前拓扑不完整，无法进行端口角色分配测试。</skipped></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_root_bridge_election" time="51.399"><failure message="Failed: DUT的RSTP实现不符合IEEE 802.1D标准。设置最低优先级后仍不是根桥。这是DUT的问题，不是测试脚本的问题。">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000018AD781A210&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD78FFB60&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000018AD77326D0&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000018AD79CF350&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000018AD79E15B0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD79E2450&gt;

    def test_root_bridge_election(self, dut_manager, test_nodes,
                                network_topology, rstp_analyzer):
        """TC.AUTO.1.1: 根网桥选举测试"""
        logger.info("开始根网桥选举测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 等待初始拓扑稳定
        time.sleep(3)
    
        # 确定DUT的正确网桥名称（DUT使用OVS+SE_ETH2）
        logger.info("=== 检查DUT网桥配置 ===")
        if hasattr(dut_manager, 'execute'):
            execute_method = dut_manager.execute
        elif hasattr(dut_manager, 'run'):
            execute_method = dut_manager.run
        else:
            execute_method = dut_manager.send_command
    
        # DUT使用OVS，网桥名称为SE_ETH2
        bridge_name = "SE_ETH2"
        logger.info(f"DUT使用OVS网桥: {bridge_name}")
    
        try:
            # 检查OVS网桥是否存在
            result = execute_method(f"sudo ovs-vsctl br-exists {bridge_name}")
            if isinstance(result, tuple) and result[2] == 0:  # 命令成功
                logger.info(f"OVS网桥 {bridge_name} 存在")
            else:
                logger.warning(f"OVS网桥 {bridge_name} 不存在，可能需要先创建拓扑")
    
            # 检查RSTP是否已启用
            result = execute_method(f"sudo ovs-vsctl get bridge {bridge_name} rstp_enable")
            if isinstance(result, tuple):
                rstp_status = result[0].strip()
                logger.info(f"{bridge_name} RSTP状态: {rstp_status}")
                if rstp_status != "true":
                    # 启用RSTP
                    execute_method(f"sudo ovs-vsctl set bridge {bridge_name} rstp_enable=true")
                    logger.info(f"已启用{bridge_name}的RSTP")
    
        except Exception as e:
            logger.warning(f"OVS网桥检查出错: {e}")
    
        # 重新获取网桥信息确保分析器使用正确的网桥
        logger.info("=== 初始网桥状态 ===")
        initial_info = rstp_analyzer.get_bridge_info()
    
        # 检查端口数量
        active_ports = [p for p in initial_info.ports.values() if p.state != PortState.DISABLED]
        logger.info(f"活动端口数: {len(active_ports)}")
    
        if len(active_ports) &lt; 2:
            logger.warning("活动端口不足，尝试启用更多端口")
            # DUT设备使用br3和br4作为网口
            for iface in ['br3', 'br4']:
                try:
                    # 启用网络接口
                    execute_method(f"sudo ip link set {iface} up")
                    # 检查端口是否已在OVS网桥中
                    result = execute_method(f"sudo ovs-vsctl port-to-br {iface}")
                    if isinstance(result, tuple) and result[2] != 0:  # 端口不在网桥中
                        execute_method(f"sudo ovs-vsctl add-port {bridge_name} {iface}")
                        logger.info(f"已将端口 {iface} 添加到OVS网桥 {bridge_name}")
                except Exception as e:
                    logger.warning(f"配置端口 {iface} 失败: {e}")
            time.sleep(3)
            initial_info = rstp_analyzer.get_bridge_info()
            active_ports = [p for p in initial_info.ports.values() if p.state != PortState.DISABLED]
    
        # 显示所有端口信息
        logger.info("初始端口状态:")
        for port_name, port_info in initial_info.ports.items():
            if port_info.state != PortState.DISABLED:
                logger.info(f"  {port_name}: 角色={port_info.role.value}, 状态={port_info.state.value}")
    
        has_root_port_initial = any(
            port.role == PortRole.ROOT
            for port in initial_info.ports.values()
            if port.state != PortState.DISABLED
        )
        logger.info(f"初始状态 - DUT有Root Port: {has_root_port_initial}")
    
        # 设置节点优先级
        logger.info("=== 配置网桥优先级 ===")
    
        # TestNode1 设置为最低优先级（应该成为根桥）
        logger.info("设置TestNode1优先级为16384")
        network_topology.execute_bridge_command(test_nodes[0], "set_priority", priority=16384)
    
        # DUT设置为较高优先级（使用OVS命令）
        logger.info("设置DUT优先级为32768")
        try:
            # 使用OVS命令设置优先级
            cmd = f"sudo ovs-vsctl set bridge {bridge_name} other-config:rstp-priority=32768"
            result = execute_method(cmd)
            logger.info(f"OVS设置优先级结果: {result}")
    
            # 验证设置
            verify_cmd = f"sudo ovs-vsctl get bridge {bridge_name} other-config:rstp-priority"
            result = execute_method(verify_cmd)
            logger.info(f"验证优先级设置: {result}")
    
        except Exception as e:
            logger.error(f"设置DUT优先级失败: {e}")
    
        # TestNode2设置中间优先级
        if len(test_nodes) &gt; 1:
            logger.info("设置TestNode2优先级为24576")
            network_topology.execute_bridge_command(test_nodes[1], "set_priority", priority=24576)
    
        # 等待收敛
        logger.info("等待RSTP收敛...")
        time.sleep(10)
    
        # 第一阶段验证
        logger.info("=== 第一阶段验证 ===")
        # DUT使用SE_ETH2网桥，需要传递正确的网桥名称
        info_phase1 = rstp_analyzer.get_bridge_info(bridge_name)
    
        # 验证优先级（使用OVS命令）
        try:
            priority_cmd = f"sudo ovs-vsctl get bridge {bridge_name} other-config:stp-priority"
            priority = execute_method(priority_cmd)
            # 处理OVS返回的格式：去除引号和换行符
            if isinstance(priority, tuple):
                priority_value = priority[0]
            else:
                priority_value = str(priority)
    
            # 使用增强的字符串清理函数
            import re
            priority_value = self._clean_ovs_output(priority_value)
    
            logger.info(f"DUT当前优先级: {priority_value}")
            # 验证优先级设置是否正确
            if priority_value != "32768":
                logger.warning(f"优先级验证失败: 期望32768，实际{priority_value}")
            else:
                logger.info("优先级验证通过")
        except Exception as e:
            logger.warning(f"优先级验证失败: {e}")
    
        # 分析端口角色
        has_root_port = False
        for port_name, port_info in info_phase1.ports.items():
            if port_info.state != PortState.DISABLED:
                logger.info(f"  {port_name}: 角色={port_info.role.value}")
                if port_info.role == PortRole.ROOT:
                    has_root_port = True
    
        if has_root_port:
            logger.info("✓ 第一阶段通过：DUT有Root Port，不是根桥")
        else:
            # 如果没有Root Port，检查是否所有端口都是Designated
            all_designated = all(
                p.role == PortRole.DESIGNATED
                for p in info_phase1.ports.values()
                if p.state != PortState.DISABLED
            )
            if all_designated and len([p for p in info_phase1.ports.values() if p.state != PortState.DISABLED]) &gt; 0:
                logger.error("DUT是根桥（所有端口都是Designated），但不应该是")
                # 这可能是因为其他节点的优先级设置失败
                logger.info("检查其他节点的优先级...")
                for i, node in enumerate(test_nodes):
                    try:
                        if hasattr(node, 'execute'):
                            node_exec = node.execute
                        else:
                            node_exec = node.send_command
                        # TestNode使用br0网桥
                        test_bridge_name = "br0"
                        result = node_exec(f"cat /sys/class/net/{test_bridge_name}/bridge/priority")
                        logger.info(f"TestNode{i+1}优先级: {result}")
                    except:
                        pass
    
        # 第二阶段：设置DUT为最低优先级
        logger.info("\n=== 第二阶段：DUT应成为根桥 ===")
        logger.info("设置DUT优先级为12288（最低）")
    
        try:
            # 设置最低优先级（使用正确的OVS命令）
            cmd = f"sudo ovs-vsctl set bridge {bridge_name} other-config:stp-priority=12288"
            result = execute_method(cmd)
            logger.info(f"OVS设置最低优先级结果: {result}")
    
            # 验证设置
            verify_cmd = f"sudo ovs-vsctl get bridge {bridge_name} other-config:stp-priority"
            priority = execute_method(verify_cmd)
            # 处理OVS返回的格式：去除引号和换行符
            if isinstance(priority, tuple):
                priority_value = priority[0]
            else:
                priority_value = str(priority)
    
            # 使用增强的字符串清理函数
            priority_value = self._clean_ovs_output(priority_value)
    
            logger.info(f"设置后优先级: {priority_value}")
    
            # 验证优先级设置是否正确
            if priority_value != "12288":
                logger.warning(f"优先级验证失败: 期望12288，实际{priority_value}")
            else:
                logger.info("最低优先级设置验证通过")
    
        except Exception as e:
            logger.error(f"设置最低优先级失败: {e}")
    
        # 等待收敛
        logger.info("等待RSTP重新收敛...")
        time.sleep(10)
    
        # 最终验证
        logger.info("=== 最终验证 ===")
        # DUT使用SE_ETH2网桥，需要传递正确的网桥名称
        final_info = rstp_analyzer.get_bridge_info(bridge_name)
    
        # 分析最终状态
        final_has_root_port = False
        designated_count = 0
    
        for port_name, port_info in final_info.ports.items():
            if port_info.state != PortState.DISABLED:
                logger.info(f"  {port_name}: 角色={port_info.role.value}, 状态={port_info.state.value}")
                if port_info.role == PortRole.ROOT:
                    final_has_root_port = True
                elif port_info.role == PortRole.DESIGNATED:
                    designated_count += 1
    
        # 判断测试结果
        if not final_has_root_port and designated_count &gt; 0:
            logger.info("✓ DUT成为根桥")
            # 验证所有端口
            for port_name, port_info in final_info.ports.items():
                if port_info.state != PortState.DISABLED:
                    assert port_info.role == PortRole.DESIGNATED, \
                        f"根桥端口{port_name}应是Designated，实际{port_info.role.value}"
                    assert port_info.state == PortState.FORWARDING, \
                        f"根桥端口{port_name}应是Forwarding，实际{port_info.state.value}"
        else:
            # 测试失败 - DUT的RSTP实现可能有问题
            logger.error("DUT RSTP实现问题诊断:")
            logger.error(f"1. DUT优先级已设置为12288（最低）")
            logger.error(f"2. 但DUT仍有Root Port: {final_has_root_port}")
            logger.error(f"3. Designated端口数: {designated_count}")
            logger.error("可能的原因:")
            logger.error("- DUT的RSTP实现不符合标准")
            logger.error("- DUT没有正确处理优先级变化")
            logger.error("- DUT的BPDU发送/接收有问题")
    
&gt;           pytest.fail(
                f"DUT的RSTP实现不符合IEEE 802.1D标准。"
                f"设置最低优先级后仍不是根桥。"
                f"这是DUT的问题，不是测试脚本的问题。"
            )
E           Failed: DUT的RSTP实现不符合IEEE 802.1D标准。设置最低优先级后仍不是根桥。这是DUT的问题，不是测试脚本的问题。

tests\test_protocol_conformance.py:402: Failed</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_port_role_assignment" time="34.810"><failure message="AssertionError: 单端口应该是Root或Designated角色，实际: PortRole.ALTERNATE&#10;assert &lt;PortRole.ALTERNATE: 'alternate'&gt; in [&lt;PortRole.ROOT: 'root'&gt;, &lt;PortRole.DESIGNATED: 'designated'&gt;]&#10; +  where &lt;PortRole.ALTERNATE: 'alternate'&gt; = PortInfo(name='br4', role=&lt;PortRole.ALTERNATE: 'alternate'&gt;, state=&lt;PortState.DISCARDING: 'discarding'&gt;, path_cost=0, designated_bridge='', designated_port='').role">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000018AD781A0D0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD78FFB60&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000018AD77326D0&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000018AD79CF350&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000018AD79E15B0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD7A6F770&gt;
convergence_monitor = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x0000018AD783D7F0&gt;

    def test_port_role_assignment(self, dut_manager, test_nodes,
                                network_topology, rstp_analyzer, convergence_monitor):
        """TC.AUTO.1.2: 端口角色与状态分配测试"""
        logger.info("开始端口角色分配测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 确保测试节点1是根网桥
        network_topology.execute_bridge_command(test_nodes[0], "set_priority", priority=12288)
        network_topology.execute_bridge_command(dut_manager, "set_priority", priority=32768)
    
        # 等待初始配置生效
        time.sleep(3)
    
        # 确保DUT的OVS网桥接口已正确配置
        logger.info("检查DUT的OVS网桥接口...")
        try:
            # 使用正确的SSH方法
            if hasattr(dut_manager, 'execute'):
                execute_method = dut_manager.execute
            elif hasattr(dut_manager, 'run'):
                execute_method = dut_manager.run
            else:
                execute_method = dut_manager.send_command
    
            # DUT使用OVS网桥SE_ETH2
            bridge_name = "SE_ETH2"
    
            # 检查OVS网桥状态
            result = execute_method(f"sudo ovs-vsctl show")
            logger.info(f"OVS配置状态:\n{result}")
    
            # 检查网桥端口
            result = execute_method(f"sudo ovs-vsctl list-ports {bridge_name}")
            logger.info(f"{bridge_name} 网桥端口:\n{result}")
    
            # 检查STP状态（OVS中RSTP基于STP实现）
            result = execute_method(f"sudo ovs-vsctl get bridge {bridge_name} stp_enable")
            logger.info(f"{bridge_name} STP状态:\n{result}")
    
            # 如果STP未启用，则启用它
            if isinstance(result, tuple) and result[0].strip() != "true":
                execute_method(f"sudo ovs-vsctl set bridge {bridge_name} stp_enable=true")
                logger.info(f"已启用{bridge_name}的STP")
                time.sleep(2)
    
            # 检查端口信息（使用ovs-ofctl show命令）
            result = execute_method(f"sudo ovs-ofctl show {bridge_name}")
            logger.info(f"{bridge_name} 端口信息:\n{result}")
    
        except Exception as e:
            logger.warning(f"检查OVS配置时出错: {e}")
    
        # 获取初始桥信息
        logger.info("获取初始网桥状态...")
        # DUT使用SE_ETH2网桥，需要传递正确的网桥名称
        initial_info = rstp_analyzer.get_bridge_info(bridge_name)
    
        # 调试信息
        logger.info(f"Bridge ID: {initial_info.bridge_id if initial_info.bridge_id else '未获取'}")
        logger.info(f"Root ID: {initial_info.root_id if initial_info.root_id else '未获取'}")
        logger.info(f"Root Port: {initial_info.root_port}")
        logger.info(f"协议版本: {initial_info.protocol_version}")
    
        # 打印所有端口状态
        for port_name, port_info in initial_info.ports.items():
            logger.info(f"端口 {port_name}: 角色={port_info.role.value}, "
                    f"状态={port_info.state.value}, 成本={port_info.path_cost}")
    
        # 等待网络收敛（不使用timeout参数）
        logger.info("等待网络收敛...")
        convergence_monitor.wait_for_convergence([rstp_analyzer])
    
        # 再次获取桥信息
        # DUT使用SE_ETH2网桥，需要传递正确的网桥名称
        info = rstp_analyzer.get_bridge_info(bridge_name)
    
        # 重新打印端口状态
        logger.info("收敛后的端口状态:")
        for port_name, port_info in info.ports.items():
            logger.info(f"端口 {port_name}: 角色={port_info.role.value}, "
                    f"状态={port_info.state.value}, 成本={port_info.path_cost}")
    
        # 判断是否为根桥
        is_root_bridge = False
    
        try:
            # 方法1：调用 is_root_bridge 方法（传递正确的网桥名称）
            is_root_result = rstp_analyzer.is_root_bridge(bridge_name)
            logger.info(f"is_root_bridge() 返回: {is_root_result}")
    
            # 方法2：检查是否有 Root Port
            has_root_port = any(
                port.role == PortRole.ROOT
                for port in info.ports.values()
                if port.state != PortState.DISABLED
            )
            logger.info(f"有Root Port: {has_root_port}")
    
            # 如果有Root Port，则不是根桥
            if has_root_port:
                is_root_bridge = False
            # 如果所有活动端口都是Designated，则是根桥
            elif all(port.role == PortRole.DESIGNATED
                    for port in info.ports.values()
                    if port.state != PortState.DISABLED):
                is_root_bridge = True
    
        except Exception as e:
            logger.warning(f"判断根桥状态时出错: {e}")
    
        logger.info(f"最终判定 - DUT是根桥: {is_root_bridge}")
    
        # 分析端口状态
        active_ports = {}
        disabled_ports = []
    
        for port_name, port_info in info.ports.items():
            if port_info.state == PortState.DISABLED:
                disabled_ports.append(port_name)
            else:
                active_ports[port_name] = port_info
    
        logger.info(f"活动端口数: {len(active_ports)}")
        logger.info(f"禁用端口: {disabled_ports}")
    
        # 如果活动端口太少，尝试手动启用禁用的端口
        if len(active_ports) &lt; 2 and disabled_ports:
            logger.warning(f"活动端口不足，尝试启用禁用的端口...")
    
            for port in disabled_ports[:2]:  # 尝试启用前两个禁用的端口
                try:
                    logger.info(f"尝试启用端口 {port}")
                    # 使用OVS命令启用端口
                    execute_method(f"sudo ip link set {port} up")
                    # 检查端口是否已在OVS网桥中
                    result = execute_method(f"sudo ovs-vsctl port-to-br {port}")
                    if isinstance(result, tuple) and result[2] != 0:  # 端口不在网桥中
                        execute_method(f"sudo ovs-vsctl add-port {bridge_name} {port}")
                        logger.info(f"已将端口 {port} 添加到OVS网桥 {bridge_name}")
                except Exception as e:
                    logger.warning(f"启用端口 {port} 失败: {e}")
    
            # 等待端口状态更新
            time.sleep(5)
    
            # 重新获取信息
            # DUT使用SE_ETH2网桥，需要传递正确的网桥名称
            info = rstp_analyzer.get_bridge_info(bridge_name)
            active_ports = {name: port for name, port in info.ports.items()
                        if port.state != PortState.DISABLED}
            disabled_ports = [name for name, port in info.ports.items()
                            if port.state == PortState.DISABLED]
    
            logger.info(f"重新配置后 - 活动端口数: {len(active_ports)}")
            logger.info(f"重新配置后 - 禁用端口: {disabled_ports}")
    
        # 统计角色
        roles = {}
        for port_name, port_info in active_ports.items():
            roles.setdefault(port_info.role, []).append(port_name)
    
        logger.info(f"端口角色分布: {roles}")
    
        # 验证逻辑
        if len(active_ports) == 0:
            pytest.fail("没有活动端口，网络配置失败")
        elif len(active_ports) == 1:
            # 单端口情况的验证
            logger.warning("只有一个活动端口，进行单端口验证")
            port_name = list(active_ports.keys())[0]
            port_info = active_ports[port_name]
    
            logger.info(f"单端口 {port_name}: 角色={port_info.role}, 状态={port_info.state}")
    
            # 单端口可能是Root（连接到根桥）或Designated（如果是孤立端口）
&gt;           assert port_info.role in [PortRole.ROOT, PortRole.DESIGNATED], \
                f"单端口应该是Root或Designated角色，实际: {port_info.role}"
E           AssertionError: 单端口应该是Root或Designated角色，实际: PortRole.ALTERNATE
E           assert &lt;PortRole.ALTERNATE: 'alternate'&gt; in [&lt;PortRole.ROOT: 'root'&gt;, &lt;PortRole.DESIGNATED: 'designated'&gt;]
E            +  where &lt;PortRole.ALTERNATE: 'alternate'&gt; = PortInfo(name='br4', role=&lt;PortRole.ALTERNATE: 'alternate'&gt;, state=&lt;PortState.DISCARDING: 'discarding'&gt;, path_cost=0, designated_bridge='', designated_port='').role

tests\test_protocol_conformance.py:587: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_rstp_protocol_verification" time="62.074" /><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_alternate_port_verification" time="23.343"><failure message="AssertionError: 环形拓扑中应该至少有2个活动端口，实际: 1&#10;assert 1 &gt;= 2&#10; +  where 1 = len({'br4': PortInfo(name='br4', role=&lt;PortRole.ALTERNATE: 'alternate'&gt;, state=&lt;PortState.DISCARDING: 'discarding'&gt;, path_cost=0, designated_bridge='', designated_port='')})">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000018AD782DCD0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD78FFB60&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000018AD77326D0&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000018AD79CF350&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000018AD79E15B0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD7A6FE30&gt;
convergence_monitor = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x0000018AD783FB60&gt;

    def test_alternate_port_verification(self, dut_manager, test_nodes,
                                        network_topology, rstp_analyzer, convergence_monitor):
        """专门测试Alternate Port的验证"""
        logger.info("开始Alternate Port验证测试")
    
        # 创建三节点环形拓扑以确保产生Alternate Port
        network_topology.create_ring_topology(use_rstp=True)
    
        # 设置不同的网桥优先级确保DUT不是根桥
        logger.info("设置网桥优先级")
        network_topology.execute_bridge_command(test_nodes[0], "set_priority", priority=4096)
        network_topology.execute_bridge_command(dut_manager, "set_priority", priority=8192)
        if len(test_nodes) &gt; 1:
            network_topology.execute_bridge_command(test_nodes[1], "set_priority", priority=12288)
    
        # 等待充分的收敛时间
        logger.info("等待RSTP收敛...")
        convergence_monitor.wait_for_convergence([rstp_analyzer])
    
        # 分析DUT的端口角色 - 使用正确的网桥名称SE_ETH2
        dut_info = rstp_analyzer.get_bridge_info("SE_ETH2")
        logger.info(f"DUT桥信息: {dut_info}")
    
        # 确保DUT不是根桥 - 传递正确的网桥名称SE_ETH2
        is_root = rstp_analyzer.is_root_bridge("SE_ETH2")
        logger.info(f"DUT根桥判断结果: {is_root}")
        logger.info(f"DUT桥信息 - bridge_id: '{dut_info.bridge_id}', root_id: '{dut_info.root_id}'")
    
        # 如果bridge_id或root_id为空，说明解析失败，不能依赖is_root_bridge判断
        if not dut_info.bridge_id or not dut_info.root_id or dut_info.bridge_id == '' or dut_info.root_id == '':
            logger.warning("DUT桥信息解析不完整，跳过根桥判断，继续端口角色验证")
        else:
            assert not is_root, f"DUT不应该是根桥（优先级设置为8192），bridge_id={dut_info.bridge_id}, root_id={dut_info.root_id}"
    
        # 分析端口角色
        roles, active_ports, disabled_ports = analyze_port_roles(dut_info)
    
        logger.info(f"活动端口数量: {len(active_ports)}")
        logger.info(f"端口角色分布: {roles}")
    
        # 在三节点环形拓扑中，非根桥应该至少有2个活动端口
&gt;       assert len(active_ports) &gt;= 2, f"环形拓扑中应该至少有2个活动端口，实际: {len(active_ports)}"
E       AssertionError: 环形拓扑中应该至少有2个活动端口，实际: 1
E       assert 1 &gt;= 2
E        +  where 1 = len({'br4': PortInfo(name='br4', role=&lt;PortRole.ALTERNATE: 'alternate'&gt;, state=&lt;PortState.DISCARDING: 'discarding'&gt;, path_cost=0, designated_bridge='', designated_port='')})

tests\test_protocol_conformance.py:913: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_port_state_transitions" time="69.964" /><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_bpdu_propagation_and_keepalive" time="22.148"><failure message="AssertionError: 在10秒内应该至少捕获到4个BPDU，实际: 0&#10;assert 0 &gt;= 4">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000018AD78606B0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD78FFB60&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000018AD77326D0&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000018AD79CF350&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000018AD79E15B0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD7A6FCB0&gt;
convergence_monitor = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x0000018AD783F230&gt;

    def test_bpdu_propagation_and_keepalive(self, dut_manager, test_nodes,
                                           network_topology, rstp_analyzer, convergence_monitor):
        """测试BPDU传播和保活机制"""
        logger.info("开始BPDU传播和保活机制测试")
    
        # 创建环形拓扑以测试分布式BPDU生成
        network_topology.create_ring_topology(use_rstp=True)
    
        # 设置不同优先级
        network_topology.execute_bridge_command(test_nodes[0], "set_priority", priority=4096)
        network_topology.execute_bridge_command(dut_manager, "set_priority", priority=8192)
        if len(test_nodes) &gt; 1:
            network_topology.execute_bridge_command(test_nodes[1], "set_priority", priority=12288)
    
        # 等待初始收敛
        logger.info("等待初始收敛...")
        convergence_monitor.wait_for_convergence([rstp_analyzer])
    
        # 获取Hello Time配置
        dut_info = rstp_analyzer.get_bridge_info()
        hello_time = getattr(dut_info, 'hello_time', 2)  # 默认2秒
        logger.info(f"Hello Time: {hello_time}秒")
    
        # 开始BPDU捕获
        logger.info("开始捕获BPDU报文")
        capture_duration = hello_time * 5  # 捕获5个Hello Time周期
    
        # 获取DUT的活动端口
        active_ports = [name for name, port in dut_info.ports.items()
                       if port.state != PortState.DISABLED]
    
        assert len(active_ports) &gt; 0, "需要至少一个活动端口进行BPDU测试"
    
        # 在每个活动端口上捕获BPDU
        bpdu_captures = {}
        for port_name in active_ports:
            logger.info(f"在端口{port_name}上开始BPDU捕获")
            try:
                # 使用rstp_analyzer的capture_bpdu方法
                bpdus = rstp_analyzer.capture_bpdu(port_name, duration=capture_duration)
                bpdu_captures[port_name] = bpdus
                logger.info(f"端口{port_name}捕获到{len(bpdus)}个BPDU")
            except Exception as e:
                logger.warning(f"端口{port_name}BPDU捕获失败: {e}")
                bpdu_captures[port_name] = []
    
        # 验证BPDU传播
        total_bpdus = sum(len(bpdus) for bpdus in bpdu_captures.values())
        logger.info(f"总共捕获到{total_bpdus}个BPDU")
    
        # 在RSTP中，所有交换机都应该定期发送BPDU
        # 预期在capture_duration时间内至少收到几个BPDU
        expected_min_bpdus = max(1, capture_duration // hello_time - 1)
&gt;       assert total_bpdus &gt;= expected_min_bpdus, \
            f"在{capture_duration}秒内应该至少捕获到{expected_min_bpdus}个BPDU，实际: {total_bpdus}"
E       AssertionError: 在10秒内应该至少捕获到4个BPDU，实际: 0
E       assert 0 &gt;= 4

tests\test_protocol_conformance.py:1073: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_disabled_port_exclusion" time="51.476"><failure message="AssertionError: 非根桥应该仍有Root Port&#10;assert &lt;PortRole.ROOT: 'root'&gt; in {}&#10; +  where &lt;PortRole.ROOT: 'root'&gt; = PortRole.ROOT">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000018AD78607C0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD78FFB60&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000018AD77326D0&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000018AD79CF350&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000018AD79E15B0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD7A6F9B0&gt;
convergence_monitor = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x0000018AD783FE00&gt;

    def test_disabled_port_exclusion(self, dut_manager, test_nodes,
                                    network_topology, rstp_analyzer, convergence_monitor):
        """测试禁用端口被正确排除在STP计算之外"""
        logger.info("开始禁用端口排除测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 设置优先级
        network_topology.execute_bridge_command(test_nodes[0], "set_priority", priority=4096)
        network_topology.execute_bridge_command(dut_manager, "set_priority", priority=8192)
    
        # 等待初始收敛
        logger.info("等待初始收敛...")
        convergence_monitor.wait_for_convergence([rstp_analyzer])
    
        # 获取初始状态
        initial_info = rstp_analyzer.get_bridge_info()
        logger.info(f"所有端口信息: {initial_info.ports}")
    
        # 添加调试：查看原始RSTP输出
        stdout, _, code = dut_manager.execute_as_root("ovs-appctl rstp/show SE_ETH2")
        logger.info(f"RSTP show输出 (code={code}): {stdout}")
    
        if code != 0:
            stdout, _, code = dut_manager.execute_as_root("ovs-appctl stp/show SE_ETH2")
            logger.info(f"STP show输出 (code={code}): {stdout}")
    
        initial_active_ports = {name: port for name, port in initial_info.ports.items()
                               if port.state != PortState.DISABLED}
    
        logger.info(f"初始活动端口: {list(initial_active_ports.keys())}")
    
        # 如果没有活动端口，尝试获取所有端口
        if not initial_active_ports:
            logger.info("没有找到活动端口，使用所有端口")
            initial_active_ports = initial_info.ports
    
        assert len(initial_active_ports) &gt;= 1, "需要至少1个端口进行禁用测试"
    
        # 选择一个非Root Port进行禁用测试
        test_port_name = None
        for name, port in initial_active_ports.items():
            if port.role != PortRole.ROOT:
                test_port_name = name
                break
    
        if not test_port_name:
            # 如果没有非Root Port，选择任意一个端口
            test_port_name = list(initial_active_ports.keys())[0]
    
        logger.info(f"选择端口{test_port_name}进行禁用测试")
        initial_port_role = initial_active_ports[test_port_name].role
    
        # 显式禁用端口
        logger.info(f"禁用端口{test_port_name}")
        result = network_topology.execute_bridge_command(dut_manager, "disable_port", port=test_port_name)
        logger.info(f"禁用命令结果: {result}")
    
        # 检查端口配置
        stdout, stderr, code = dut_manager.execute_as_root(f"ovs-vsctl get Port {test_port_name} other_config")
        logger.info(f"端口{test_port_name}配置: stdout='{stdout}', stderr='{stderr}', code={code}")
    
        # 等待拓扑重新收敛
        time.sleep(15)
    
        # 验证端口已被禁用
        disabled_info = rstp_analyzer.get_bridge_info()
        logger.info(f"禁用后所有端口状态: {[(p.name, p.state.value) for p in disabled_info.ports.values()]}")
    
        disabled_port = disabled_info.ports.get(test_port_name)
    
        if not disabled_port:
            logger.error(f"端口{test_port_name}不存在于端口列表中")
            return
    
        logger.info(f"端口{test_port_name}状态: {disabled_port.state.value}, 角色: {disabled_port.role.value}")
    
        # 暂时注释掉断言，先看看实际情况
        # assert disabled_port.state == PortState.DISABLED, \
        #     f"端口{test_port_name}应该是DISABLED状态，实际: {disabled_port.state}"
    
        # 验证其他端口的状态
        current_active_ports = {name: port for name, port in disabled_info.ports.items()
                               if port.state != PortState.DISABLED}
    
        logger.info(f"禁用后活动端口: {list(current_active_ports.keys())}")
        logger.info(f"活动端口数量: {len(current_active_ports)}, 初始活动端口数量: {len(initial_active_ports)}")
    
        # 3. 验证网络仍然无环路且连通
        roles, active_ports, disabled_ports = analyze_port_roles(disabled_info)
        logger.info(f"禁用后端口角色分布: {roles}")
    
        # 验证基本的STP规则仍然满足
        if not rstp_analyzer.is_root_bridge():
&gt;           assert PortRole.ROOT in roles, "非根桥应该仍有Root Port"
E           AssertionError: 非根桥应该仍有Root Port
E           assert &lt;PortRole.ROOT: 'root'&gt; in {}
E            +  where &lt;PortRole.ROOT: 'root'&gt; = PortRole.ROOT

tests\test_protocol_conformance.py:1201: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_topology_change_notification" time="31.015" /><testcase classname="tests.test_security.TestSecurity" name="test_root_bridge_hijack_attack" time="25.984"><failure message="AssertionError: DUT应该是初始根网桥&#10;assert False&#10; +  where False = is_root_bridge()&#10; +    where is_root_bridge = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD79E18B0&gt;.is_root_bridge">self = &lt;test_security.TestSecurity object at 0x0000018AD781A490&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD79FC6E0&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000018AD79D5470&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000018AD79D6660&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000018AD79E0950&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD79E18B0&gt;

    def test_root_bridge_hijack_attack(self, dut_manager, test_nodes,
                                       network_topology, rstp_analyzer):
        """TC.AUTO.4.1: 根网桥劫持攻击测试"""
        logger.info("开始根网桥劫持攻击测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # DUT作为根网桥
        dut_manager.execute_sudo("brctl setbridgeprio br0 16384")
        if test_nodes:
            test_nodes[0].execute_sudo("brctl setbridgeprio br0 32768")
    
        time.sleep(5)
    
        # 验证DUT是根网桥
&gt;       assert rstp_analyzer.is_root_bridge(), "DUT应该是初始根网桥"
E       AssertionError: DUT应该是初始根网桥
E       assert False
E        +  where False = is_root_bridge()
E        +    where is_root_bridge = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD79E18B0&gt;.is_root_bridge

tests\test_security.py:37: AssertionError</failure></testcase><testcase classname="tests.test_security.TestSecurity" name="test_bpdu_flood_attack" time="35.549" /><testcase classname="tests.test_security.TestSecurity" name="test_topology_change_attack" time="45.781" /><testcase classname="tests.test_security.TestSecurity" name="test_mac_spoofing" time="37.155" /><testcase classname="tests.test_security.TestSecurity" name="test_port_security" time="0.053"><skipped type="pytest.skip" message="端口安全功能不可用">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_security.py:249: 端口安全功能不可用</skipped></testcase><testcase classname="tests.test_security.TestSecurity" name="test_bpdu_filter_functionality" time="45.264" /><testcase classname="tests.test_security.TestSecurity" name="test_malformed_bpdu_handling" time="59.672" /><testcase classname="tests.test_security.TestSecurity" name="test_non_standard_bpdu_handling" time="42.680" /><testcase classname="tests.test_security.TestSecurity" name="test_bpdu_guard_functionality" time="31.921"><failure message="Failed: BPDU防护未能正确禁用端口">self = &lt;test_security.TestSecurity object at 0x0000018AD7811C50&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD79FC6E0&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000018AD79D5470&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000018AD79D6660&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000018AD79E0950&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD79E3950&gt;

    def test_bpdu_guard_functionality(self, dut_manager, test_nodes,
                                        network_topology, rstp_analyzer):
        """测试BPDU防护功能"""
        logger.info("开始BPDU防护功能测试")
    
        edge_port = "eth2"  # 假设eth2是边缘端口
        test_passed = False
    
        try:
            # 检查SSH连接状态
            if not dut_manager.is_connected():
                logger.error("SSH连接未激活")
                pytest.fail("SSH连接失败，无法执行测试")
    
            # 创建线性拓扑用于测试边缘端口
            network_topology.create_linear_topology(use_rstp=True)
            time.sleep(5)
    
            # 在DUT上启用BPDU防护
            try:
                self._enable_bpdu_guard(dut_manager, edge_port)
            except Exception as e:
                logger.error(f"启用BPDU防护失败: {e}")
                pytest.fail(f"BPDU防护配置失败: {e}")
    
            # 记录初始端口状态
            initial_port_state = self._get_port_state(dut_manager, edge_port)
            logger.info(f"边缘端口 {edge_port} 初始状态: {initial_port_state}")
    
            if test_nodes:
                # 从测试节点向边缘端口发送BPDU
                logger.info(f"向边缘端口 {edge_port} 发送BPDU")
                self._send_bpdu_to_edge_port(test_nodes[0], edge_port)
    
                # 等待BPDU防护生效
                time.sleep(3)
    
                # 检查端口是否被err-disabled
                final_port_state = self._get_port_state(dut_manager, edge_port)
                logger.info(f"BPDU防护触发后端口 {edge_port} 状态: {final_port_state}")
    
                # 验证端口被正确禁用
                if "err-disabled" in final_port_state.lower() or "disabled" in final_port_state.lower():
                    logger.info("BPDU防护功能正常：端口已被禁用")
                    test_passed = True
                else:
                    logger.error("BPDU防护功能异常：端口未被禁用")
&gt;                   pytest.fail("BPDU防护未能正确禁用端口")
E                   Failed: BPDU防护未能正确禁用端口

tests\test_security.py:797: Failed</failure></testcase><testcase classname="tests.test_security.TestSecurity" name="test_root_guard_functionality" time="53.928"><failure message="Failed: 根防护功能测试未通过验证">self = &lt;test_security.TestSecurity object at 0x0000018AD776F7A0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000018AD79FC6E0&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000018AD79D5470&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000018AD79D6660&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000018AD79E0950&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000018AD7A5A8D0&gt;

    def test_root_guard_functionality(self, dut_manager, test_nodes,
                                       network_topology, rstp_analyzer):
        """测试根防护功能"""
        logger.info("开始根防护功能测试")
    
        guard_port = "eth1"  # 假设eth1连接到可能的攻击源
        test_passed = False
    
        try:
            # 检查SSH连接状态
            if not dut_manager.is_connected():
                logger.error("SSH连接未激活")
                pytest.fail("SSH连接失败，无法执行测试")
    
            # 创建环形拓扑
            network_topology.create_ring_topology(use_rstp=True)
            time.sleep(5)
    
            # 获取当前根桥信息
            initial_bridge_info = rstp_analyzer.get_bridge_info()
            current_root_id = initial_bridge_info.root_id if initial_bridge_info else None
            logger.info(f"当前根桥ID: {current_root_id}")
    
            # 在DUT上启用根防护
            try:
                self._enable_root_guard(dut_manager, guard_port)
                logger.info(f"在端口 {guard_port} 启用根防护")
            except Exception as e:
                logger.error(f"启用根防护失败: {e}")
                pytest.fail(f"根防护配置失败: {e}")
    
            # 记录初始端口状态
            initial_port_state = self._get_port_state(dut_manager, guard_port)
            logger.info(f"端口 {guard_port} 初始状态: {initial_port_state}")
    
            if test_nodes:
                # 从测试节点发送更优的BPDU（尝试成为新根桥）
                logger.info("发送更优BPDU尝试劫持根桥")
                self._send_superior_bpdu(test_nodes[0])
    
                # 等待根防护生效
                time.sleep(5)
    
                # 检查端口是否进入root-inconsistent状态
                final_port_state = self._get_port_state(dut_manager, guard_port)
                logger.info(f"根防护触发后端口 {guard_port} 状态: {final_port_state}")
    
                # 验证根桥没有改变
                final_bridge_info = rstp_analyzer.get_bridge_info()
                final_root_id = final_bridge_info.root_id if final_bridge_info else None
    
                if current_root_id == final_root_id:
                    logger.info("根防护功能正常：根桥身份未被劫持")
                    test_passed = True
                else:
                    logger.error(f"根防护功能异常：根桥从 {current_root_id} 变为 {final_root_id}")
                    pytest.fail("根防护未能阻止根桥劫持")
    
                # 验证端口状态
                if "root-inconsistent" in final_port_state.lower() or "blocking" in final_port_state.lower():
                    logger.info("根防护功能正常：端口进入阻塞状态")
                else:
                    logger.error("根防护功能异常：端口未进入阻塞状态")
                    test_passed = False
    
                # 测试根防护恢复
                self._test_root_guard_recovery(dut_manager, test_nodes[0], guard_port)
    
        except Exception as e:
            logger.error(f"根防护测试失败: {e}")
            pytest.fail(f"根防护测试执行失败: {e}")
        finally:
            # 清理：禁用根防护
            try:
                self._cleanup_root_guard(dut_manager, guard_port)
            except Exception as e:
                logger.error(f"清理根防护配置失败: {e}")
    
        if not test_passed:
&gt;           pytest.fail("根防护功能测试未通过验证")
E           Failed: 根防护功能测试未通过验证

tests\test_security.py:919: Failed</failure></testcase><testcase classname="tests.test_security.TestSecurity" name="test_loop_guard_functionality" time="55.647" /></testsuite></testsuites>