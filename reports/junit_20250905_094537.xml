<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="4" failures="15" skipped="1" tests="31" time="681.320" timestamp="2025-09-05T09:45:39.202791+08:00" hostname="DESKTOP-FDB8GR9"><testcase classname="tests.test_convergence.TestConvergence" name="test_direct_link_failure" time="390.495"><failure message="TypeError: 'BridgeInfo' object is not subscriptable">self = &lt;test_convergence.TestConvergence object at 0x000001C2EADC7750&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAEE01A0&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x000001C2EAEC1090&gt;, &lt;src.ssh_manager.SSHManager object at 0x000001C2EAEC2710&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x000001C2EAEE17F0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAEE1940&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x000001C2EAEE1A90&gt;
convergence_monitor = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x000001C2EAEE1BE0&gt;

    def test_direct_link_failure(self, dut_manager, test_nodes,
                                 network_topology, rstp_analyzer,
                                 fault_injector, convergence_monitor):
        """TC.AUTO.2.1: 直接链路故障测试"""
        logger.info("开始直接链路故障测试")
    
        # 创建网状拓扑提供冗余路径
        network_topology.create_mesh_topology(use_rstp=True)
    
        # 等待初始收敛
        analyzers = [rstp_analyzer] + [RSTPAnalyzer(node) for node in test_nodes]
&gt;       initial_convergence = convergence_monitor.wait_for_convergence(analyzers)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_convergence.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x000001C2EAEE1BE0&gt;
analyzers = [&lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAEE1940&gt;, &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAEC3890&gt;, &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAEC3610&gt;]

    def wait_for_convergence(self, analyzers: List[RSTPAnalyzer]) -&gt; float:
        """等待网络收敛"""
        start_time = time.time()
        self.logger.info(f"等待网络收敛 (最长{self.timeout}秒)...")
    
        while time.time() - start_time &lt; self.timeout:
            converged = True
            for analyzer in analyzers:
                info = analyzer.get_bridge_info()
&gt;               for port, data in info['ports'].items():
                                  ^^^^^^^^^^^^^
E               TypeError: 'BridgeInfo' object is not subscriptable

conftest.py:212: TypeError</failure></testcase><testcase classname="tests.test_convergence.TestConvergence" name="test_root_bridge_failure" time="0.046"><error message="failed on setup with &quot;RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe&quot;">fixturedef = &lt;FixtureDef argname='vmware_controller' scope='session' baseid=''&gt;
request = &lt;SubRequest 'vmware_controller' for &lt;Function test_root_bridge_failure&gt;&gt;

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -&gt; object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
&gt;               return (yield)
                        ^^^^^

..\..\..\AppData\Roaming\Python\Python313\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
conftest.py:94: in vmware_controller
    return VMwareController(vmrun_path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;src.vmware_controller.VMwareController object at 0x000001C2EAEE2A50&gt;
vmrun_path = 'C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe'

    def __init__(self, vmrun_path: str = "/usr/bin/vmrun"):
        """
        初始化VMware控制器
    
        Args:
            vmrun_path: vmrun工具路径
        """
        self.vmrun = vmrun_path
        self.logger = logging.getLogger("VMwareController")
    
        # 验证vmrun是否存在
        if not self._check_vmrun():
&gt;           raise RuntimeError(f"vmrun工具未找到: {vmrun_path}")
E           RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe

src\vmware_controller.py:48: RuntimeError</error></testcase><testcase classname="tests.test_convergence.TestConvergence" name="test_multiple_link_failures" time="35.017"><failure message="TypeError: 'BridgeInfo' object is not subscriptable">self = &lt;test_convergence.TestConvergence object at 0x000001C2EAD5AD70&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAEE01A0&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x000001C2EAEC1090&gt;, &lt;src.ssh_manager.SSHManager object at 0x000001C2EAEC2710&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x000001C2EAEE17F0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAEFDBA0&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x000001C2EB020F50&gt;
convergence_monitor = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x000001C2EAEE2BA0&gt;

    @pytest.mark.slow
    def test_multiple_link_failures(self, dut_manager, test_nodes,
                                    network_topology, rstp_analyzer,
                                    fault_injector, convergence_monitor):
        """测试多重链路故障"""
        logger.info("开始多重链路故障测试")
    
        # 创建网状拓扑
        network_topology.create_mesh_topology(use_rstp=True)
    
        # 等待初始收敛
        analyzers = [rstp_analyzer] + [RSTPAnalyzer(node) for node in test_nodes]
&gt;       convergence_monitor.wait_for_convergence(analyzers)

tests\test_convergence.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x000001C2EAEE2BA0&gt;
analyzers = [&lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAEFDBA0&gt;, &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAEFDCD0&gt;, &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAEC83B0&gt;]

    def wait_for_convergence(self, analyzers: List[RSTPAnalyzer]) -&gt; float:
        """等待网络收敛"""
        start_time = time.time()
        self.logger.info(f"等待网络收敛 (最长{self.timeout}秒)...")
    
        while time.time() - start_time &lt; self.timeout:
            converged = True
            for analyzer in analyzers:
                info = analyzer.get_bridge_info()
&gt;               for port, data in info['ports'].items():
                                  ^^^^^^^^^^^^^
E               TypeError: 'BridgeInfo' object is not subscriptable

conftest.py:212: TypeError</failure></testcase><testcase classname="tests.test_convergence.TestConvergence" name="test_convergence_with_traffic" time="35.143" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_primary_controller_failure" time="0.001"><error message="failed on setup with &quot;RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe&quot;">test_config = {'rstp_parameters': {'bridge_priority': {'invalid': [4097, 12289, 70000], 'max': 61440, 'min': 12288, 'step': 4096}, '... {'interfaces': ['eth0', 'eth2', 'eth1'], 'ip': '192.168.13.137', 'name': 'TestNode2', 'password': '8N10xiaol', ...}]}}

    @pytest.fixture(scope="session")
    def vmware_controller(test_config):
        """VMware控制器fixture"""
        vmrun_path = test_config['test_environment']['vmware']['vmrun_path']
&gt;       return VMwareController(vmrun_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

conftest.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;src.vmware_controller.VMwareController object at 0x000001C2EAEE2A50&gt;
vmrun_path = 'C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe'

    def __init__(self, vmrun_path: str = "/usr/bin/vmrun"):
        """
        初始化VMware控制器
    
        Args:
            vmrun_path: vmrun工具路径
        """
        self.vmrun = vmrun_path
        self.logger = logging.getLogger("VMwareController")
    
        # 验证vmrun是否存在
        if not self._check_vmrun():
&gt;           raise RuntimeError(f"vmrun工具未找到: {vmrun_path}")
E           RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe

src\vmware_controller.py:48: RuntimeError</error></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_rstp_reconvergence_no_switchover" time="21.124"><failure message="NameError: name 'FaultInjector' is not defined">self = &lt;test_high_availability.TestHighAvailability object at 0x000001C2EADC7ED0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAEFE520&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x000001C2EAEFF100&gt;, &lt;src.ssh_manager.SSHManager object at 0x000001C2EAE0D490&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x000001C2EADC74D0&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAECCF30&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x000001C2EAEFFCE0&gt;
ha_setup = {'primary': {'ip': '192.168.100.10', 'vm_path': '/path/to/primary.vmx'}, 'standby': {'ip': '192.168.100.11', 'vm_path': '/path/to/standby.vmx'}, 'sync_interface': 'eth3', 'vip': '192.168.100.100'}

    def test_rstp_reconvergence_no_switchover(self, dut_manager, test_nodes,
                                             network_topology, rstp_analyzer,
                                             fault_injector, ha_setup):
        """TC.AUTO.5.2: RSTP重构不应导致误判切换"""
        logger.info("开始RSTP重构误判测试")
    
        # 创建包含HA对的网络拓扑
        network_topology.create_mesh_topology(use_rstp=True)
        time.sleep(5)
    
        # 监控HA状态
        initial_ha_state = self._get_ha_status(dut_manager)
        logger.info(f"初始HA状态: {initial_ha_state}")
    
        # 在远端触发RSTP重构
        if len(test_nodes) &gt;= 2:
            # 断开远端链路
            remote_node = test_nodes[-1]
&gt;           remote_injector = FaultInjector(remote_node)
                              ^^^^^^^^^^^^^
E           NameError: name 'FaultInjector' is not defined

tests\test_high_availability.py:127: NameError</failure></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_split_brain_scenario" time="10.186" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_ha_switchover_with_traffic" time="0.001"><error message="failed on setup with &quot;RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe&quot;">test_config = {'rstp_parameters': {'bridge_priority': {'invalid': [4097, 12289, 70000], 'max': 61440, 'min': 12288, 'step': 4096}, '... {'interfaces': ['eth0', 'eth2', 'eth1'], 'ip': '192.168.13.137', 'name': 'TestNode2', 'password': '8N10xiaol', ...}]}}

    @pytest.fixture(scope="session")
    def vmware_controller(test_config):
        """VMware控制器fixture"""
        vmrun_path = test_config['test_environment']['vmware']['vmrun_path']
&gt;       return VMwareController(vmrun_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

conftest.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;src.vmware_controller.VMwareController object at 0x000001C2EAEE2A50&gt;
vmrun_path = 'C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe'

    def __init__(self, vmrun_path: str = "/usr/bin/vmrun"):
        """
        初始化VMware控制器
    
        Args:
            vmrun_path: vmrun工具路径
        """
        self.vmrun = vmrun_path
        self.logger = logging.getLogger("VMwareController")
    
        # 验证vmrun是否存在
        if not self._check_vmrun():
&gt;           raise RuntimeError(f"vmrun工具未找到: {vmrun_path}")
E           RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe

src\vmware_controller.py:48: RuntimeError</error></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_ha_failback" time="0.002"><error message="failed on setup with &quot;RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe&quot;">test_config = {'rstp_parameters': {'bridge_priority': {'invalid': [4097, 12289, 70000], 'max': 61440, 'min': 12288, 'step': 4096}, '... {'interfaces': ['eth0', 'eth2', 'eth1'], 'ip': '192.168.13.137', 'name': 'TestNode2', 'password': '8N10xiaol', ...}]}}

    @pytest.fixture(scope="session")
    def vmware_controller(test_config):
        """VMware控制器fixture"""
        vmrun_path = test_config['test_environment']['vmware']['vmrun_path']
&gt;       return VMwareController(vmrun_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

conftest.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;src.vmware_controller.VMwareController object at 0x000001C2EAEE2A50&gt;
vmrun_path = 'C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe'

    def __init__(self, vmrun_path: str = "/usr/bin/vmrun"):
        """
        初始化VMware控制器
    
        Args:
            vmrun_path: vmrun工具路径
        """
        self.vmrun = vmrun_path
        self.logger = logging.getLogger("VMwareController")
    
        # 验证vmrun是否存在
        if not self._check_vmrun():
&gt;           raise RuntimeError(f"vmrun工具未找到: {vmrun_path}")
E           RuntimeError: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe

src\vmware_controller.py:48: RuntimeError</error></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[12288]" time="0.239"><failure message="AssertionError: 设置优先级失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000001C2EAEC0190&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAF20F30&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAF22140&gt;
priority = 12288

    @pytest.mark.parametrize("priority", [12288, 16384, 32768, 61440])
    def test_bridge_priority_valid(self, dut_manager, rstp_analyzer, priority):
        """TC.AUTO.3.1.1-2: 测试有效的网桥优先级"""
        logger.info(f"测试网桥优先级: {priority}")
    
        # 设置网桥优先级
        stdout, stderr, code = NetworkTopology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
&gt;       assert code == 0, f"设置优先级失败: {stderr}"
E       AssertionError: 设置优先级失败: 
E       assert 1 == 0

tests\test_parameters.py:43: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[16384]" time="0.088"><failure message="AssertionError: 设置优先级失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000001C2EAEC02D0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAF20F30&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB070E50&gt;
priority = 16384

    @pytest.mark.parametrize("priority", [12288, 16384, 32768, 61440])
    def test_bridge_priority_valid(self, dut_manager, rstp_analyzer, priority):
        """TC.AUTO.3.1.1-2: 测试有效的网桥优先级"""
        logger.info(f"测试网桥优先级: {priority}")
    
        # 设置网桥优先级
        stdout, stderr, code = NetworkTopology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
&gt;       assert code == 0, f"设置优先级失败: {stderr}"
E       AssertionError: 设置优先级失败: 
E       assert 1 == 0

tests\test_parameters.py:43: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[32768]" time="0.085"><failure message="AssertionError: 设置优先级失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000001C2EAD5B490&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAF20F30&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB071450&gt;
priority = 32768

    @pytest.mark.parametrize("priority", [12288, 16384, 32768, 61440])
    def test_bridge_priority_valid(self, dut_manager, rstp_analyzer, priority):
        """TC.AUTO.3.1.1-2: 测试有效的网桥优先级"""
        logger.info(f"测试网桥优先级: {priority}")
    
        # 设置网桥优先级
        stdout, stderr, code = NetworkTopology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
&gt;       assert code == 0, f"设置优先级失败: {stderr}"
E       AssertionError: 设置优先级失败: 
E       assert 1 == 0

tests\test_parameters.py:43: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[61440]" time="0.079"><failure message="AssertionError: 设置优先级失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000001C2EAD5B6F0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAF20F30&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAFA57C0&gt;
priority = 61440

    @pytest.mark.parametrize("priority", [12288, 16384, 32768, 61440])
    def test_bridge_priority_valid(self, dut_manager, rstp_analyzer, priority):
        """TC.AUTO.3.1.1-2: 测试有效的网桥优先级"""
        logger.info(f"测试网桥优先级: {priority}")
    
        # 设置网桥优先级
        stdout, stderr, code = NetworkTopology.execute_bridge_command(
            dut_manager, "set_priority", priority=priority
        )
&gt;       assert code == 0, f"设置优先级失败: {stderr}"
E       AssertionError: 设置优先级失败: 
E       assert 1 == 0

tests\test_parameters.py:43: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[4097]" time="0.085" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[12289]" time="0.100" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[70000]" time="0.093" /><testcase classname="tests.test_parameters.TestParameters" name="test_hello_time" time="0.094"><failure message="AssertionError: 设置Hello Time失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000001C2EAEA8750&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAF20F30&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAFA6120&gt;

    def test_hello_time(self, dut_manager, rstp_analyzer):
        """TC.AUTO.3.1.4: Hello Time测试"""
        logger.info("测试Hello Time参数")
    
        # 测试不同的hello time值
        for hello_time in [1, 2, 5]:
            logger.info(f"设置Hello Time: {hello_time}秒")
    
            # 设置参数
            stdout, stderr, code = NetworkTopology.execute_bridge_command(
                dut_manager, "set_hello_time", hello_time=hello_time
            )
&gt;           assert code == 0, f"设置Hello Time失败: {stderr}"
E           AssertionError: 设置Hello Time失败: 
E           assert 1 == 0

tests\test_parameters.py:94: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_forward_delay" time="0.077"><failure message="AssertionError: 设置Forward Delay失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000001C2EAEA8950&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAF20F30&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAF7BD90&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x000001C2EAEC97F0&gt;

    def test_forward_delay(self, dut_manager, rstp_analyzer, fault_injector):
        """TC.AUTO.3.1.5: Forward Delay测试"""
        logger.info("测试Forward Delay参数")
    
        # 测试不同的forward delay值
        for fd in [4, 10, 15]:
            logger.info(f"设置Forward Delay: {fd}秒")
    
            # 设置参数
            stdout, stderr, code = NetworkTopology.execute_bridge_command(
                dut_manager, "set_forward_delay", forward_delay=fd
            )
&gt;           assert code == 0, f"设置Forward Delay失败: {stderr}"
E           AssertionError: 设置Forward Delay失败: 
E           assert 1 == 0

tests\test_parameters.py:134: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_max_age" time="0.084"><failure message="AssertionError: 设置Max Age失败: &#10;assert 1 == 0">self = &lt;test_parameters.TestParameters object at 0x000001C2EADF65D0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAF20F30&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EAF7B150&gt;

    def test_max_age(self, dut_manager, rstp_analyzer):
        """TC.AUTO.3.1.6: Max Age测试"""
        logger.info("测试Max Age参数")
    
        for max_age in [6, 10, 20]:
            logger.info(f"设置Max Age: {max_age}秒")
    
            # 设置参数
            stdout, stderr, code = NetworkTopology.execute_bridge_command(
                dut_manager, "set_max_age", max_age=max_age
            )
&gt;           assert code == 0, f"设置Max Age失败: {stderr}"
E           AssertionError: 设置Max Age失败: 
E           assert 1 == 0

tests\test_parameters.py:183: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_port_cost" time="20.221" /><testcase classname="tests.test_parameters.TestParameters" name="test_parameter_persistence" time="3.599"><failure message="AssertionError: Hello Time不匹配: 0 != 2&#10;assert 0 == 2&#10; +  where 0 = BridgeInfo(bridge_id='', root_id='', root_port='', root_path_cost=0, protocol_version='unknown', hello_time=0, forward_delay=0, max_age=0, topology_changes=0, ports={}).hello_time">self = &lt;test_parameters.TestParameters object at 0x000001C2EAEC4AD0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EAF20F30&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB03CB90&gt;

    def test_parameter_persistence(self, dut_manager, rstp_analyzer):
        """测试参数持久性"""
        logger.info("测试参数持久性")
    
        # 设置多个参数
        params = {
            'priority': 16384,
            'hello': 2,
            'fd': 15,
            'maxage': 20
        }
    
        # 应用参数
        for param, value in params.items():
            if param == 'priority':
                cmd = f"brctl setbridgeprio br0 {value}"
            elif param == 'hello':
                cmd = f"brctl sethello br0 {value}"
            elif param == 'fd':
                cmd = f"brctl setfd br0 {value}"
            elif param == 'maxage':
                cmd = f"brctl setmaxage br0 {value}"
    
            dut_manager.execute_sudo(cmd)
    
        time.sleep(3)
    
        # 验证所有参数
        info = rstp_analyzer.get_bridge_info()
    
        # 检查优先级
        if '.' in info.bridge_id:
            actual_priority = int(info.bridge_id.split('.')[0], 16)
            assert actual_priority == params['priority'], \
                f"优先级不匹配: {actual_priority} != {params['priority']}"
    
        # 检查时间参数
&gt;       assert info.hello_time == params['hello'], \
            f"Hello Time不匹配: {info.hello_time} != {params['hello']}"
E       AssertionError: Hello Time不匹配: 0 != 2
E       assert 0 == 2
E        +  where 0 = BridgeInfo(bridge_id='', root_id='', root_port='', root_path_cost=0, protocol_version='unknown', hello_time=0, forward_delay=0, max_age=0, topology_changes=0, ports={}).hello_time

tests\test_parameters.py:267: AssertionError</failure></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_parameter_boundaries" time="1.497" /><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_root_bridge_election" time="21.088"><failure message="AssertionError: DUT不应该是根网桥（优先级较高）&#10;assert not True&#10; +  where True = is_root_bridge()&#10; +    where is_root_bridge = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB03C890&gt;.is_root_bridge">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x000001C2EAEC0410&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EB070650&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x000001C2EADF7D40&gt;, &lt;src.ssh_manager.SSHManager object at 0x000001C2EAFA49B0&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x000001C2EAEFFE10&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB03C890&gt;

    def test_root_bridge_election(self, dut_manager, test_nodes,
                                  network_topology, rstp_analyzer):
        """TC.AUTO.1.1: 根网桥选举测试"""
        logger.info("开始根网桥选举测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 设置节点优先级
        NetworkTopology.execute_bridge_command(test_nodes[0], "set_priority", priority=16384)
        NetworkTopology.execute_bridge_command(dut_manager, "set_priority", priority=32768)
    
        # 等待收敛
        time.sleep(5)
    
        # 验证DUT不是根网桥
&gt;       assert not rstp_analyzer.is_root_bridge(), \
            "DUT不应该是根网桥（优先级较高）"
E       AssertionError: DUT不应该是根网桥（优先级较高）
E       assert not True
E        +  where True = is_root_bridge()
E        +    where is_root_bridge = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB03C890&gt;.is_root_bridge

tests\test_protocol_conformance.py:36: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_port_role_assignment" time="12.268"><failure message="AssertionError: DUT应该有Root Port&#10;assert &lt;PortRole.ROOT: 'root'&gt; in {}&#10; +  where &lt;PortRole.ROOT: 'root'&gt; = PortRole.ROOT">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x000001C2EAEC0550&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EB070650&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x000001C2EADF7D40&gt;, &lt;src.ssh_manager.SSHManager object at 0x000001C2EAFA49B0&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x000001C2EAEFFE10&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB07D020&gt;

    def test_port_role_assignment(self, dut_manager, test_nodes,
                                  network_topology, rstp_analyzer):
        """TC.AUTO.1.2: 端口角色与状态分配测试"""
        logger.info("开始端口角色分配测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 确保测试节点1是根网桥
        NetworkTopology.execute_bridge_command(test_nodes[0], "set_priority", priority=12288)
        NetworkTopology.execute_bridge_command(dut_manager, "set_priority", priority=32768)
    
        # 等待收敛
        time.sleep(5)
    
        # 获取DUT端口信息
        info = rstp_analyzer.get_bridge_info()
    
        # 统计端口角色
        roles = {}
        for port_name, port_info in info.ports.items():
            role = port_info.role
            if role not in roles:
                roles[role] = []
            roles[role].append(port_name)
    
        # 验证有且仅有一个Root Port
&gt;       assert PortRole.ROOT in roles, "DUT应该有Root Port"
E       AssertionError: DUT应该有Root Port
E       assert &lt;PortRole.ROOT: 'root'&gt; in {}
E        +  where &lt;PortRole.ROOT: 'root'&gt; = PortRole.ROOT

tests\test_protocol_conformance.py:84: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_rstp_protocol_verification" time="0.373"><failure message="AssertionError: DUT应该使用RSTP协议&#10;assert False&#10; +  where False = verify_rstp_enabled()&#10; +    where verify_rstp_enabled = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB07D5A0&gt;.verify_rstp_enabled">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x000001C2EAD5B820&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EB070650&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB07D5A0&gt;

    def test_rstp_protocol_verification(self, dut_manager, rstp_analyzer):
        """验证使用的是RSTP而不是STP"""
        logger.info("开始RSTP协议验证")
    
        # 验证协议版本
&gt;       assert rstp_analyzer.verify_rstp_enabled(), \
            "DUT应该使用RSTP协议"
E       AssertionError: DUT应该使用RSTP协议
E       assert False
E        +  where False = verify_rstp_enabled()
E        +    where verify_rstp_enabled = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB07D5A0&gt;.verify_rstp_enabled

tests\test_protocol_conformance.py:105: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_topology_change_notification" time="19.453"><failure message="AssertionError: 应该检测到拓扑变更&#10;assert 0 &gt; 0">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x000001C2EAD5B950&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x000001C2EB070650&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x000001C2EADF7D40&gt;, &lt;src.ssh_manager.SSHManager object at 0x000001C2EAFA49B0&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x000001C2EAEFFE10&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x000001C2EB091A90&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x000001C2EAECFCE0&gt;

    def test_topology_change_notification(self, dut_manager, test_nodes,
                                          network_topology, rstp_analyzer,
                                          fault_injector):
        """测试拓扑变更通知机制"""
        logger.info("开始拓扑变更通知测试")
    
        # 创建稳定拓扑
        network_topology.create_ring_topology(use_rstp=True)
        time.sleep(5)
    
        # 记录初始拓扑变更计数
        initial_info = rstp_analyzer.get_bridge_info()
        initial_changes = initial_info.topology_changes
    
        # 触发拓扑变更
        fault_injector.link_down("eth0")
        time.sleep(2)
        fault_injector.link_up("eth0")
        time.sleep(5)
    
        # 检查拓扑变更计数
        final_info = rstp_analyzer.get_bridge_info()
        final_changes = final_info.topology_changes
    
&gt;       assert final_changes &gt; initial_changes, \
            "应该检测到拓扑变更"
E       AssertionError: 应该检测到拓扑变更
E       assert 0 &gt; 0

tests\test_protocol_conformance.py:145: AssertionError</failure></testcase><testcase classname="tests.test_security.TestSecurity" name="test_root_bridge_hijack_attack" time="36.364" /><testcase classname="tests.test_security.TestSecurity" name="test_bpdu_flood_attack" time="22.994" /><testcase classname="tests.test_security.TestSecurity" name="test_topology_change_attack" time="31.076" /><testcase classname="tests.test_security.TestSecurity" name="test_mac_spoofing" time="18.520" /><testcase classname="tests.test_security.TestSecurity" name="test_port_security" time="0.012"><skipped type="pytest.skip" message="端口安全功能不可用">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_security.py:249: 端口安全功能不可用</skipped></testcase></testsuite></testsuites>