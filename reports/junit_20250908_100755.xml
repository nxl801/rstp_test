<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="5" skipped="5" tests="31" time="921.603" timestamp="2025-09-08T10:07:56.969926+08:00" hostname="DESKTOP-FDB8GR9"><testcase classname="tests.test_convergence.TestConvergence" name="test_direct_link_failure" time="399.671"><failure message="AssertionError: 未找到Root Port&#10;assert None">self = &lt;test_convergence.TestConvergence object at 0x0000017E4FC874D0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000017E4FCABCB0&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000017E4FD54E10&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000017E4FD56490&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000017E4FD79400&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000017E4FD79550&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x0000017E4FD796A0&gt;
convergence_monitor = &lt;conftest.convergence_monitor.&lt;locals&gt;.ConvergenceMonitor object at 0x0000017E4FD797F0&gt;

    def test_direct_link_failure(self, dut_manager, test_nodes,
                                 network_topology, rstp_analyzer,
                                 fault_injector, convergence_monitor):
        """TC.AUTO.2.1: 直接链路故障测试"""
        logger.info("开始直接链路故障测试")
    
        # 创建环形拓扑提供冗余路径
        network_topology.create_ring_topology(use_rstp=True)
    
        # 调整优先级，确保 DUT 不是根网桥
        NetworkTopology.execute_bridge_command(test_nodes[0], "set_priority", priority=16384)
        NetworkTopology.execute_bridge_command(dut_manager, "set_priority", priority=32768)
        if len(test_nodes) &gt; 1:
            NetworkTopology.execute_bridge_command(test_nodes[1], "set_priority", priority=28672)
    
        # 等待初始收敛
        analyzers = [rstp_analyzer] + [RSTPAnalyzer(node) for node in test_nodes]
        initial_convergence = convergence_monitor.wait_for_convergence(analyzers)
        logger.info(f"初始收敛时间: {initial_convergence:.2f}秒")
    
        # 确定DUT的Root Port
        info = rstp_analyzer.get_bridge_info()
        root_port = None
        for port_name, port_info in info.ports.items():
            if port_info.role == PortRole.ROOT:
                root_port = port_name
                break
    
&gt;       assert root_port, "未找到Root Port"
E       AssertionError: 未找到Root Port
E       assert None

tests\test_convergence.py:50: AssertionError</failure></testcase><testcase classname="tests.test_convergence.TestConvergence" name="test_root_bridge_failure" time="0.163"><skipped type="pytest.skip" message="跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_convergence.py:80: 跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe</skipped></testcase><testcase classname="tests.test_convergence.TestConvergence" name="test_multiple_link_failures" time="47.710" /><testcase classname="tests.test_convergence.TestConvergence" name="test_convergence_with_traffic" time="40.227" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_primary_controller_failure" time="0.000"><skipped type="pytest.skip" message="跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_high_availability.py:40: 跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe</skipped></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_rstp_reconvergence_no_switchover" time="33.400" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_split_brain_scenario" time="10.205" /><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_ha_switchover_with_traffic" time="0.001"><skipped type="pytest.skip" message="跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_high_availability.py:178: 跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe</skipped></testcase><testcase classname="tests.test_high_availability.TestHighAvailability" name="test_ha_failback" time="0.002"><skipped type="pytest.skip" message="跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_high_availability.py:227: 跳过需要VMware控制的测试: vmrun工具未找到: C:/Program Files (x86)/VMware/VMware Workstation/vmrun.exe</skipped></testcase><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[12288]" time="2.237" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[16384]" time="2.092" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[32768]" time="2.079" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_valid[61440]" time="2.079" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[4097]" time="0.057" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[12289]" time="0.051" /><testcase classname="tests.test_parameters.TestParameters" name="test_bridge_priority_invalid[70000]" time="0.052" /><testcase classname="tests.test_parameters.TestParameters" name="test_hello_time" time="6.253" /><testcase classname="tests.test_parameters.TestParameters" name="test_forward_delay" time="6.238" /><testcase classname="tests.test_parameters.TestParameters" name="test_max_age" time="6.242" /><testcase classname="tests.test_parameters.TestParameters" name="test_port_cost" time="128.964" /><testcase classname="tests.test_parameters.TestParameters" name="test_parameter_persistence" time="3.701" /><testcase classname="tests.test_parameters.TestParameters" name="test_parameter_boundaries" time="0.882" /><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_root_bridge_election" time="57.847"><failure message="AssertionError: DUT不应该是根网桥（优先级较高）&#10;assert not True&#10; +  where True = is_root_bridge()&#10; +    where is_root_bridge = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000017E4FCBBE90&gt;.is_root_bridge">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000017E4FD54190&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000017E4FD3B550&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000017E4FE84B90&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000017E4FE86030&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000017E4FD73490&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000017E4FCBBE90&gt;

    def test_root_bridge_election(self, dut_manager, test_nodes,
                                  network_topology, rstp_analyzer):
        """TC.AUTO.1.1: 根网桥选举测试"""
        logger.info("开始根网桥选举测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 设置节点优先级
        NetworkTopology.execute_bridge_command(test_nodes[0], "set_priority", priority=16384)
        NetworkTopology.execute_bridge_command(dut_manager, "set_priority", priority=32768)
    
        # 等待收敛
        time.sleep(5)
    
        # 验证DUT不是根网桥
&gt;       assert not rstp_analyzer.is_root_bridge(), \
            "DUT不应该是根网桥（优先级较高）"
E       AssertionError: DUT不应该是根网桥（优先级较高）
E       assert not True
E        +  where True = is_root_bridge()
E        +    where is_root_bridge = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000017E4FCBBE90&gt;.is_root_bridge

tests\test_protocol_conformance.py:36: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_port_role_assignment" time="16.875"><failure message="AssertionError: DUT应该有Root Port&#10;assert &lt;PortRole.ROOT: 'root'&gt; in {}&#10; +  where &lt;PortRole.ROOT: 'root'&gt; = PortRole.ROOT">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000017E4FD542D0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000017E4FD3B550&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000017E4FE84B90&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000017E4FE86030&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000017E4FD73490&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000017E4FDFBE30&gt;

    def test_port_role_assignment(self, dut_manager, test_nodes,
                                  network_topology, rstp_analyzer):
        """TC.AUTO.1.2: 端口角色与状态分配测试"""
        logger.info("开始端口角色分配测试")
    
        # 创建环形拓扑
        network_topology.create_ring_topology(use_rstp=True)
    
        # 确保测试节点1是根网桥
        NetworkTopology.execute_bridge_command(test_nodes[0], "set_priority", priority=12288)
        NetworkTopology.execute_bridge_command(dut_manager, "set_priority", priority=32768)
    
        # 等待收敛
        time.sleep(5)
    
        # 获取DUT端口信息
        info = rstp_analyzer.get_bridge_info()
    
        # 统计端口角色
        roles = {}
        for port_name, port_info in info.ports.items():
            role = port_info.role
            if role not in roles:
                roles[role] = []
            roles[role].append(port_name)
    
        # 验证有且仅有一个Root Port
&gt;       assert PortRole.ROOT in roles, "DUT应该有Root Port"
E       AssertionError: DUT应该有Root Port
E       assert &lt;PortRole.ROOT: 'root'&gt; in {}
E        +  where &lt;PortRole.ROOT: 'root'&gt; = PortRole.ROOT

tests\test_protocol_conformance.py:84: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_rstp_protocol_verification" time="0.127"><failure message="AssertionError: 应该检测到RSTP BPDU&#10;assert 0 &gt; 0&#10; +  where 0 = len([])">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000017E4FBF3BB0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000017E4FD3B550&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000017E4FEB41B0&gt;

    def test_rstp_protocol_verification(self, dut_manager, rstp_analyzer):
        """验证使用的是RSTP而不是STP"""
        logger.info("开始RSTP协议验证")
    
        # 验证协议版本
        assert rstp_analyzer.verify_rstp_enabled(), \
            "DUT应该使用RSTP协议"
    
        # 检查BPDU格式
        bpdus = rstp_analyzer.capture_bpdu("eth0", count=5, timeout=15)
    
        rstp_bpdus = [b for b in bpdus if b.get('is_rstp', False)]
&gt;       assert len(rstp_bpdus) &gt; 0, "应该检测到RSTP BPDU"
E       AssertionError: 应该检测到RSTP BPDU
E       assert 0 &gt; 0
E        +  where 0 = len([])

tests\test_protocol_conformance.py:112: AssertionError</failure></testcase><testcase classname="tests.test_protocol_conformance.TestProtocolConformance" name="test_topology_change_notification" time="24.618"><failure message="AssertionError: 应该检测到拓扑变更&#10;assert 0 &gt; 0">self = &lt;test_protocol_conformance.TestProtocolConformance object at 0x0000017E4FBF3CE0&gt;
dut_manager = &lt;src.ssh_manager.SSHManager object at 0x0000017E4FD3B550&gt;
test_nodes = [&lt;src.ssh_manager.SSHManager object at 0x0000017E4FE84B90&gt;, &lt;src.ssh_manager.SSHManager object at 0x0000017E4FE86030&gt;]
network_topology = &lt;src.network_topology.NetworkTopology object at 0x0000017E4FD73490&gt;
rstp_analyzer = &lt;src.rstp_analyzer.RSTPAnalyzer object at 0x0000017E4FE69450&gt;
fault_injector = &lt;src.fault_injector.FaultInjector object at 0x0000017E4FDB5F20&gt;

    def test_topology_change_notification(self, dut_manager, test_nodes,
                                          network_topology, rstp_analyzer,
                                          fault_injector):
        """测试拓扑变更通知机制"""
        logger.info("开始拓扑变更通知测试")
    
        # 创建稳定拓扑
        network_topology.create_ring_topology(use_rstp=True)
        time.sleep(5)
    
        # 记录初始拓扑变更计数
        initial_info = rstp_analyzer.get_bridge_info()
        initial_changes = initial_info.topology_changes
    
        # 触发拓扑变更
        fault_injector.link_down("eth0")
        time.sleep(2)
        fault_injector.link_up("eth0")
        time.sleep(5)
    
        # 检查拓扑变更计数
        final_info = rstp_analyzer.get_bridge_info()
        final_changes = final_info.topology_changes
    
&gt;       assert final_changes &gt; initial_changes, \
            "应该检测到拓扑变更"
E       AssertionError: 应该检测到拓扑变更
E       assert 0 &gt; 0

tests\test_protocol_conformance.py:145: AssertionError</failure></testcase><testcase classname="tests.test_security.TestSecurity" name="test_root_bridge_hijack_attack" time="38.882" /><testcase classname="tests.test_security.TestSecurity" name="test_bpdu_flood_attack" time="27.694" /><testcase classname="tests.test_security.TestSecurity" name="test_topology_change_attack" time="38.942" /><testcase classname="tests.test_security.TestSecurity" name="test_mac_spoofing" time="23.819" /><testcase classname="tests.test_security.TestSecurity" name="test_port_security" time="0.010"><skipped type="pytest.skip" message="端口安全功能不可用">C:\Users\30380\OneDrive\101_Schneider\05_EAE_rstp_test_framework\tests\test_security.py:249: 端口安全功能不可用</skipped></testcase></testsuite></testsuites>